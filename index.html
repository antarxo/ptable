<!DOCTYPE html>
<html lang="el">
<head>
  <meta charset="UTF-8">
  <title>Περιοδικός Πίνακας - Τελική Τοποθέτηση</title>
  <link href="https://fonts.googleapis.com/css?family=Roboto&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
  <style>
    /* Βασικές ρυθμίσεις σε όλο το έγγραφο */
    body { 
      font-family: 'Roboto', sans-serif; 
      margin: 0; 
      overflow: hidden; 
      background: #f7f7f7; 
    }
    /* Ορισμοί για τους καμβάδες ώστε να μην περικόπτεται η σκιά */
    .canvas { 
      position: absolute; 
      background: transparent; 
      transition: all 0.5s ease-in-out; 
    }
    /* Σε κάθε canvas προσθέτουμε padding και CSS drop-shadow για να εμφανίζεται το εφέ */
    canvas {
      padding: 8px;
      /* Το drop-shadow εφαρμόζεται στο συνολικό canvas, δίνοντας την αίσθηση ότι κάθε κελί έχει σκιά */
      filter: drop-shadow(4px 4px 4px rgba(0,0,0,0.5));
      /* Αποτρέπουμε το clipping */
      overflow: visible;
    }
    #canvasTableBackground {
      position: absolute; 
      background: white; 
      border: 1px solid rgba(0,0,0,0.1);
      box-shadow: 0 3px 3px rgba(0,0,0,0.2); 
      z-index: -10;
      opacity: 1;
    }
    /* Οι καμβάδες για τις ομάδες – όπως στο ALLtoDOM1, διαχωρισμένοι σε 3: S, D, P */
    #canvasS_groups, #canvasD_groups, #canvasP_groups { 
      position: absolute; 
      height: 40px; 
    }
    /* Οι υπόλοιποι καμβάδες */
    #canvasPeriods, #canvasS, #canvasD, #canvasP, #canvasF {
      position: absolute;
    }
    /* Κουμπιά */
    #buttonPanel {
      position: fixed; bottom: 20px; right: 20px; z-index: 100;
      display: flex; gap: 5px;
    }
    #buttonPanel button {
      background-color: #008CBA; 
      color: white; 
      padding: 10px 15px;
      border: none; 
      border-radius: 5px; 
      cursor: pointer;
    }
  </style>
</head>
<body>

  <!-- Καμβάδες -->
  <div id="canvasTableBackground"></div>
  <!-- Καμβάδες ομάδων (S, D, P) -->
  <div id="canvasS_groups" class="canvas"></div>
  <div id="canvasD_groups" class="canvas"></div>
  <div id="canvasP_groups" class="canvas"></div>
  
  <div id="canvasPeriods" class="canvas"></div>
  <div id="canvasS" class="canvas"></div>
  <div id="canvasD" class="canvas"></div>
  <div id="canvasP" class="canvas"></div>
  <div id="canvasF" class="canvas"></div>

  <!-- Κουμπιά -->
  <div id="buttonPanel">
    <button id="fillAll">Συμπλήρωσε</button>
    <button id="toggleFBlock">Σύμπτυξε</button>
  </div>

  <script>
    let elements = [];
    let positions = {};
    let blockOffsets = {}; 
    let isTableFilled = false; // Για να δημιουργηθούν οι καμβάδες μία φορά
    // Flag για το collapsed/expanded mode (για το toggle)
    let isCollapsed = false;

    async function loadData() {
      elements = await (await fetch('elements.json')).json();
      positions = await (await fetch('positions.json')).json();
      computeBlockOffsets();
    }

    // Υπολογισμός ορίων για κάθε block (s, p, d, f)
    function computeBlockOffsets() {
      let blocks = ["s", "p", "d", "f"];
      blocks.forEach(block => {
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        Object.keys(positions.expanded).forEach(num => {
          let e = elements.find(el => el.number == num);
          if (e && e.block === block) {
            let pos = positions.expanded[num];
            minX = Math.min(minX, pos.x);
            minY = Math.min(minY, pos.y);
            maxX = Math.max(maxX, pos.x + pos.width);
            maxY = Math.max(maxY, pos.y + pos.height);
          }
        });
        blockOffsets[block] = { minX, minY, width: maxX - minX, height: maxY - minY };
      });
    }

    function calculateRelativePosition(element, block) {
      let pos = positions.expanded[element.number];
      let offset = blockOffsets[block];
      return { x: pos.x - offset.minX, y: pos.y - offset.minY };
    }

    // Δημιουργία background canvas
    function initializeBackgroundCanvas() {
      let bg = document.getElementById("canvasTableBackground");
      bg.style.left = "16px";
      bg.style.top = "50px";
      bg.style.width = "1412px";
      bg.style.height = "368px";
      bg.style.opacity = "1";
    }

    // Δημιουργία των καμβάδων ομάδων σύμφωνα με την υλοποίηση του ALLtoDOM1
    function initGroupsCanvases() {
      if(window.groupsInitialized) return;
      
      // s-block: δύο σειρές – πρώτη σειρά: νέοι αριθμοί (1,2), δεύτερη: παλιά (ΙΑ, ΙΙΑ)
      new p5(function(p) {
        p.setup = function() {
          let canvas = p.createCanvas(84, 40);
          canvas.parent("canvasS_groups");
          p.noStroke();
          p.textAlign(p.CENTER, p.CENTER);
          p.textSize(12);
          p.textStyle(p.BOLD);
          p.background(240);
          p.text("1", 20, 10);
          p.text("2", 62, 10);
          p.text("ΙΑ", 20, 30);
          p.text("ΙΙΑ", 62, 30);
        };
      });
      
      // d-block: δύο σειρές – πρώτη: νέοι αριθμοί (3–12), δεύτερη: παλιά labels
      new p5(function(p) {
        p.setup = function() {
          let canvas = p.createCanvas(418, 40);
          canvas.parent("canvasD_groups");
          p.noStroke();
          p.textAlign(p.CENTER, p.CENTER);
          p.textSize(12);
          p.textStyle(p.BOLD);
          p.background(240);
          for(let c = 0; c < 10; c++){
            let x = c * 42 + c * 2;
            p.text((c+3).toString(), x + 20, 10);
          }
          const oldLabels = ["IIIB","IVB","VB","VIB","VIIB","VIIIB","VIIIB","VIIIB","IB","IIB"];
          for(let c = 0; c < 10; c++){
            let x = c * 42 + c * 2;
            p.text(oldLabels[c], x + 20, 30);
          }
        };
      });
      
      // p-block: δύο σειρές – πρώτη: νέοι αριθμοί (13–18), δεύτερη: παλιά labels
      new p5(function(p) {
        p.setup = function() {
          let canvas = p.createCanvas(250, 40);
          canvas.parent("canvasP_groups");
          p.noStroke();
          p.textAlign(p.CENTER, p.CENTER);
          p.textSize(12);
          p.textStyle(p.BOLD);
          p.background(240);
          for(let c = 0; c < 6; c++){
            let x = c * 42 + c * 2;
            p.text((c+13).toString(), x + 20, 10);
          }
          const oldLabels = ["IIIA","IVA","VA","VIA","VIIA","VIIIA"];
          for(let c = 0; c < 6; c++){
            let x = c * 42 + c * 2;
            p.text(oldLabels[c], x + 20, 30);
          }
        };
      });
      
      // Ενημέρωση θέσεων: κάθε καμβάς ομάδας παίρνει left ίσο με το left του αντίστοιχου τομέα 
      // και top ίσο με το (top του background + 20px)
      let bgTop = parseInt(document.getElementById("canvasTableBackground").style.top) || 50;
      let sectors = ["S", "D", "P"];
      sectors.forEach(sector => {
        let sectorCanvas = document.getElementById("canvas" + sector);
        let groupCanvas = document.getElementById("canvas" + sector + "_groups");
        if(sectorCanvas && groupCanvas) {
          groupCanvas.style.left = sectorCanvas.style.left;
          groupCanvas.style.top = (bgTop + 20) + "px";
        }
      });
      
      window.groupsInitialized = true;
    }

    // Δημιουργία του canvas των περιόδων
    function initializePeriodsCanvas() {
      new p5(function(p) {
        p.setup = function() {
          let canvas = p.createCanvas(40, 294);
          canvas.parent("canvasPeriods");
          let container = document.getElementById("canvasPeriods");
          let bgLeft = parseInt(document.getElementById("canvasTableBackground").style.left);
          container.style.left = (bgLeft + 10) + "px";
          container.style.top = "110px";
          p.noStroke();
          p.textAlign(p.CENTER, p.CENTER);
          p.textSize(13);
          p.textStyle(p.BOLD);
          const periodLabels = ["1", "2", "3", "4", "5", "6", "7"];
          for (let i = 0; i < 7; i++) {
            p.fill(240);
            p.rect(5, i * 42, 35, 40);
            p.fill(0);
            p.text(periodLabels[i], 5 + 35/2, i * 42 + 20);
          }
        };
      });
    }

    // Δημιουργία των καμβάδων τομέων (s, p, d, f)
 function initializeSectorsCanvas() {
  // Έλεγχος αν υπάρχουν τα blockOffsets για το s
  if (!blockOffsets["s"]) {
    computeBlockOffsets();
    if (!blockOffsets["s"]) {
      console.error("Δεν βρέθηκαν δεδομένα για το block 's'");
      return;
    }
  }
  let desiredLeftS = 70;
  let deltaS = desiredLeftS - blockOffsets["s"].minX;
  let sectorsTop = 110;
  ["s", "p", "d", "f"].forEach(block => {
    let offset = blockOffsets[block];
    let container = document.getElementById("canvas" + block.toUpperCase());
    container.innerHTML = "";
    container.style.left = (offset.minX + deltaS) + "px";
    if (block === "s" || block === "p") {
      container.style.top = sectorsTop + "px";
    } else {
      let referenceBottom = sectorsTop + blockOffsets["s"].height;
      container.style.top = (referenceBottom - offset.height) + "px";
    }
    container.style.width = offset.width + "px";
    container.style.height = offset.height + "px";
    new p5(function(p) {
      p.setup = function() {
        let canvas = p.createCanvas(offset.width, offset.height);
        // Μην αλλάζουμε τις διαστάσεις του canvas ώστε να παραμείνουν τα κελιά 40x40
        canvas.parent("canvas" + block.toUpperCase());
        drawElements(p, block);
      };
    });
  });
}



    function drawElements(p, block) {
      let colors = { s: "#FF477E", p: "#26FF31", d: "#3F99FF", f: "#FFD051" };
      const cellWidth = 40, cellHeight = 40, cellRadius = 5;
      elements.filter(e => e.block === block).forEach(e => {
        let pos = calculateRelativePosition(e, block);
        // Αφαιρούμε το "manual" εφέ σκιάς γιατί τώρα εφαρμόζεται μέσω CSS στο canvas
        p.fill(colors[block] || "#CCCCCC");
        p.rect(pos.x, pos.y, cellWidth, cellHeight, cellRadius);
        p.fill(0);
        p.textSize(13);
        p.textStyle(p.BOLD);
        p.textAlign(p.CENTER, p.CENTER);
        p.text(e.number, pos.x + cellWidth/2, pos.y + cellHeight/2);
      });
    }

    // Κουμπί "Συμπλήρωσε" που δημιουργεί όλους τους καμβάδες
    document.getElementById('fillAll').addEventListener('click', function() {
      if (!isTableFilled) {
        initializeBackgroundCanvas();
        initGroupsCanvases();
        initializePeriodsCanvas();
        initializeSectorsCanvas();
        isTableFilled = true;
      }
    });

    // Κουμπί "Σύμπτυξε"/"Ανάπτυξε" με βασική λογική εναλλαγής
    document.getElementById('toggleFBlock').addEventListener('click', function() {
      isCollapsed = !isCollapsed;
      // Εδώ μπορείτε να προσθέσετε την πλήρη λογική μετατόπισης/αναδιάταξης όπως στο ALLtoDOM1.
      // Για παράδειγμα, αν collapsed, μετατοπίζουμε ορισμένους καμβάδες.
      // Σε αυτό το παράδειγμα απλά αλλάζουμε το κείμενο του κουμπιού.
      this.textContent = isCollapsed ? "Ανάπτυξε" : "Σύμπτυξε";
      // Επαναπροσδιορισμός θέσεων (μπορεί να καλεστεί π.χ. initializeSectorsCanvas ξανά)
      initializeSectorsCanvas();
      // Και οι καμβάδες ομάδων να επαναπροσαρμοστούν:
      let bgTop = parseInt(document.getElementById("canvasTableBackground").style.top) || 50;
      let sectors = ["S", "D", "P"];
      sectors.forEach(sector => {
        let sectorCanvas = document.getElementById("canvas" + sector);
        let groupCanvas = document.getElementById("canvas" + sector + "_groups");
        if(sectorCanvas && groupCanvas) {
          groupCanvas.style.left = sectorCanvas.style.left;
          groupCanvas.style.top = (bgTop + 20) + "px";
        }
      });
    });

    window.addEventListener('load', loadData);
  </script>

</body>
</html>
