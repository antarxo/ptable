<!DOCTYPE html>
<html lang="el">
<head>
  <meta charset="UTF-8">
  <title>Περιοδικός Πίνακας – Info Panel Transitions</title>
  <link href="https://fonts.googleapis.com/css?family=Roboto&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
  <style>
    /* Στυλ για τον τίτλο */
    #pageTitleOverlay {
      position: fixed;
      top: 5px;
      left: 50%;
      transform: translateX(-50%);
      background: white;
      box-shadow: 0 6px 12px rgba(0,0,0,0.9);
      padding: 5px 10px;
      z-index: 999;
      display: flex;
      align-items: center;
      gap: 10px;
      white-space: nowrap;
    }
    #pageTitleOverlay h1,
    #pageTitleOverlay h2 {
      display: inline-block;
      margin: 0;
      white-space: nowrap;
    }
    #pageTitleOverlay h1 {
      font-size: 24px;
      font-weight: bold;
      color: black;
      letter-spacing: 1px;
    }
    #pageTitleOverlay h2 {
      font-size: 11px;
      color: #333;
    }
    body {
      font-family: 'Roboto', sans-serif;
      margin: 0;
      overflow: hidden;
      background: #f7f7f7;
      padding-top: 60px;
    }
    .canvas {
      position: absolute;
      background: transparent;
      transition: all 0.5s ease-in-out;
    }
    canvas {
      padding: 8px;
      filter: drop-shadow(4px 4px 4px rgba(0,0,0,0.5));
      overflow: visible;
    }
    #canvasTableBackground {
      position: absolute;
      background: white;
      border: 1px solid rgba(0,0,0,0.1);
      box-shadow: 6px 6px 10px rgba(0,0,0,0.3);
      z-index: -5;
      opacity: 1;
      transition: all 0.5s ease-in-out;
    }
    /* Ομαδοποίηση καμβάδων */
    #canvasS_groups, #canvasD_groups, #canvasP_groups {
      position: absolute;
      z-index: 60;
    }
    /* Sector canvases */
    #canvasS { z-index: 10; }
    #canvasF { z-index: 20; }
    #canvasD { z-index: 30; }
    #canvasP { z-index: 40; }
    #canvasPeriods { z-index: 50; }
    /* Button panel */
    #buttonPanel {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 100;
      display: flex;
      flex-direction: column;
      gap: 5px;
    }
    #buttonPanel button {
      background-color: #008CBA;
      color: white;
      padding: 10px 15px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      box-shadow: 4px 4px 4px rgba(0,0,0,0.5);
      font-size: 1em;
    }
    /* Offscreen canvas */
    #offscreenCanvas { display: none; }
    /* Balloon overlay */
    #balloonOverlay {
      position: absolute;
      background: white;
      box-shadow: 2px 2px 6px rgba(0,0,0,0.3);
      padding: 6px 8px;
      border-radius: 5px;
      z-index: 150;
      visibility: hidden;
      opacity: 0;
      transition: opacity 0.3s ease;
      pointer-events: none;
      font-size: 13px;
    }
    /* Info Panels */
    #infoPanelFull {
      position: fixed;
      top: 0;
      left: 20px;
      background: #fff;
      border: 1px solid rgba(0,0,0,0.2);
      box-shadow: inset 0 4px 8px rgba(0,0,0,0.4);
      border-radius: 8px;
      padding: 10px;
      z-index: -10;
      transition: all 0.5s ease;
      opacity: 1;
    }
    #infoPanelCollapsed {
      position: fixed;
      background: #fff;
      border: 1px solid rgba(0,0,0,0.2);
      box-shadow: inset 0 4px 8px rgba(0,0,0,0.4);
      border-radius: 8px;
      padding: 10px;
      z-index: -20;
      transition: all 0.5s ease;
      opacity: 1;
    }
  </style>
</head>
<body>
  <!-- Overlay τίτλου -->
  <div id="pageTitleOverlay">
    <h1>
      Διαδραστική Συμπλήρωση του 
      <span id="styledPeriodicou">
        <span style="color: #8B0000;">Π</span>
        <span style="color: #FF8C00;">ε</span>
        <span style="color: #00008B;">ρ</span>
        <span style="color: #006400;">ι</span>
        <span style="color: #8B0000;">ο</span>
        <span style="color: #FF8C00;">δ</span>
        <span style="color: #00008B;">ι</span>
        <span style="color: #006400;">κ</span>
        <span style="color: #8B0000;">ο</span>
        <span style="color: #FF8C00;">ύ</span>
      </span> 
      Πίνακα
    </h1>
    <h2>2025, Created by Antonios Archontoulis, Greece</h2>
  </div>

  <!-- Καμβάδες -->
  <div id="canvasTableBackground"></div>
  <div id="canvasS_groups" class="canvas"></div>
  <div id="canvasD_groups" class="canvas"></div>
  <div id="canvasP_groups" class="canvas"></div>
  <div id="canvasPeriods" class="canvas"></div>
  <div id="canvasS" class="canvas"></div>
  <div id="canvasD" class="canvas"></div>
  <div id="canvasP" class="canvas"></div>
  <div id="canvasF" class="canvas"></div>

  <!-- Balloon Overlay -->
  <div id="balloonOverlay"></div>

  <!-- Info Panels -->
  <div id="infoPanelFull">
    <table style="width:100%; border-collapse:collapse;">
      <tr>
        <td id="infoLeft" style="width:200px;"></td>
        <td id="infoRight">
          <div id="infoSubshells"></div>
          <div id="infoRemarks"></div>
        </td>
      </tr>
    </table>
  </div>
  <div id="infoPanelCollapsed" style="display:none;"></div>

  <!-- Button Panel -->
  <div id="buttonPanel">
    <button id="nextState">Επόμενο</button>
    <button id="fillAll">Συμπλήρωσε</button>
    <button id="toggleFBlock" disabled>Σύμπτυξε</button>
    <button id="reset">Reset</button>
  </div>

  <!-- Offscreen Canvas -->
  <canvas id="offscreenCanvas" width="800" height="600"></canvas>

  <script>
    /****************** Global Variables & Configuration ******************/
    let sectorColors = { s: "#FF477E", p: "#26FF31", d: "#3F99FF", f: "#FFD051" };
    let textColors = { s: "#8B0000", p: "#006400", d: "#00008B", f: "#FF8C00" };
    let elements = [];
    let positions = {};
    let isCollapsed = false;
    let currentMode = "start";
    let currentZ = 3;
    let extraElements = {};
    let showPeriods = false;
    let cellSize = 40;
    let currentCellPositions = {};
    let currentBalloonElement = null;
    let sectorInstances = [];

    window.addEventListener('load', function(){
      const h2 = document.querySelector('#pageTitleOverlay h2');
      const h1 = document.querySelector('#pageTitleOverlay h1');
      const gap = 5;
      if(h2 && h1) {
        h1.style.paddingLeft = (h2.offsetWidth + gap) + 'px';
      }
    });

    function rowHTMLPair(element, type, showShells = true) {
      if (!element) {
        return showShells
          ? `
          <tr><td colspan="2" style="text-align:center; font-size:16px;">-</td></tr>
          <tr><td colspan="2" style="text-align:center; font-size:16px;">-</td></tr>
        `
          : `<tr><td colspan="2" style="text-align:center; font-size:16px;">-</td></tr>`;
      }
      let borderStyle = (type === "prev" || type === "current") ? "border-bottom:1px solid #ccc;" : "";
      let color = textColors[element.block] || "#CCCCCC";
      let firstRow = `
        <tr style="${borderStyle}">
          <td style="color:${color}; font-weight:bold; font-size:16px;">Ζ=${element.number}</td>
          <td style="color:${color}; font-size:16px;">${element.subshells || "-"}</td>
        </tr>
      `;
      if (showShells) {
        let secondRow = `
        <tr>
          <td></td>
          <td style="color:${color}; font-size:16px;">${formatShells(element, true)}</td>
        </tr>
        `;
        return firstRow + secondRow;
      } else {
        return firstRow;
      }
    }

    function formatShells(element, isCurrent = false) {
      if (!element.shells) return "";
      let shellCounts = element.shells.split(/,\s*/);
      let formatted = shellCounts.map((count, index) => {
         let letter = shellLetter((index+1).toString());
         return `<span style="display:inline-block; width:40px; text-align:left; margin-right:6px;">${letter}(${count})</span>`;
      });
      if (isCurrent && formatted.length > 0) {
         let last = formatted.pop();
         last = `<b>${last}</b>`;
         formatted.push(last);
      }
      return formatted.join("");
    }

    function shellLetter(n) {
      let mapping = { "1": "K", "2": "L", "3": "M", "4": "N", "5": "O", "6": "P", "7": "Q" };
      return mapping[n] || n;
    }

    function getShift(num, block) {
      if (currentMode !== "start") return 0;
      if (block === "p" && num >= 21 && num <= 30) {
        let effectiveZ = Math.min(currentZ, 30);
        return (effectiveZ - 20) * 42;
      }
      if ((block === "p" || block === "d") && num >= 57 && num <= 70) {
        let effective = Math.min(currentZ, 70);
        return (effective - 56) * 42;
      }
      return 0;
    }
    function getShiftContainer(block) {
      if (currentMode !== "start") return 0;
      if (block === "p") {
        if (currentZ <= 20) return 0;
        else if (currentZ <= 30) return (currentZ - 20) * 42;
        else if (currentZ <= 56) return 42 * 10;
        else if (currentZ <= 70) return 42 * 10 + (currentZ - 56) * 42;
        else return 42 * 10 + 42 * 14;
      } else if (block === "d") {
        if (currentZ < 57) return 0;
        else if (currentZ <= 70) return (currentZ - 56) * 42;
        else return 42 * 14;
      }
      return 0;
    }
    function computeModeRegion() {
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      elements.forEach(e => {
        let num = Number(e.number);
        if (currentMode === "start") {
          if ((num < 3 && !extraElements[num]) || num > currentZ) return;
        }
        let pos = positions[currentMode][e.number] ||
                  ((e.number === "1" || e.number === "2") ? positions["start"][e.number] : null);
        if (pos) {
          let x = pos.x, y = pos.y;
          if (currentMode === "start" && (e.block === "p" || e.block === "d")) {
            x += getShiftContainer(e.block);
            if (e.block === "p" && num >= 21 && num <= 30)
              y += getShift(num, e.block);
            else if ((e.block === "p" || e.block === "d") && num >= 57 && num <= 70)
              y += getShift(num, e.block);
          }
          minX = Math.min(minX, x);
          minY = Math.min(minY, y);
          maxX = Math.max(maxX, x + pos.width);
          maxY = Math.max(maxY, y + pos.height);
        }
      });
      return (minX === Infinity) ? null : { minX, minY, maxX, maxY };
    }
    function updateCellsPositions() {
      currentCellPositions = {};
      elements.forEach(e => {
        let num = Number(e.number);
        if (currentMode === "start") {
          if ((num < 3 && !extraElements[num]) || num > currentZ) return;
        }
        let pos = positions[currentMode][e.number] ||
                  (((e.number === "1" || e.number === "2") && extraElements[e.number]) ? positions["start"][e.number] : null);
        if (!pos) return;
        let offsetX = 0, offsetY = 0;
        if (currentMode === "start" && (e.block === "p" || e.block === "d")) {
          offsetX = getShiftContainer(e.block);
        }
        if (currentMode === "start") {
          if (e.block === "p" && num >= 21 && num <= 30)
            offsetY = getShift(num, e.block);
          else if ((e.block === "p" || e.block === "d") && num >= 57 && num <= 70)
            offsetY = getShift(num, e.block);
        }
        currentCellPositions[e.number] = {
          x: pos.x + offsetX,
          y: pos.y + offsetY,
          width: pos.width,
          height: pos.height
        };
      });
    }
    function computeModeRegionUpdated() {
      let keys = Object.keys(currentCellPositions);
      if (keys.length === 0) return null;
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      for (let key in currentCellPositions) {
        let pos = currentCellPositions[key];
        minX = Math.min(minX, pos.x);
        minY = Math.min(minY, pos.y);
        maxX = Math.max(maxX, pos.x + pos.width);
        maxY = Math.max(maxY, pos.y + pos.height);
      }
      return { minX, minY, maxX, maxY };
    }
    function initializeBackgroundCanvas() {
      let bg = document.getElementById("canvasTableBackground");
      let margin = 20;
      if (currentMode === "start") {
        let limits = computeModeRegion();
        if (limits) {
          bg.style.left = "17px";
          bg.style.top = (limits.minY - margin) + "px";
          let width = (limits.maxX - 17) + margin;
          bg.style.width = width + "px";
          bg.style.height = (limits.maxY - limits.minY + 2 * margin) + "px";
        }
      } else if (currentMode === "expanded" || currentMode === "collapsed") {
        let leftFixed = 17, topFixed = 55;
        let margin = 20;
        let limits = computeModeRegion();
        let rightLimit = limits.maxX + margin;
        let bottomLimit = limits.maxY + margin;
        bg.style.left = leftFixed + "px";
        bg.style.top = topFixed + "px";
        bg.style.width = (rightLimit - leftFixed) + "px";
        bg.style.height = (bottomLimit - topFixed) + "px";
      }
      bg.style.opacity = "1";
    }
    async function loadData() {
      let resElements = await fetch('elements.json');
      elements = await resElements.json();
      let resPositions = await fetch('positions.json');
      positions = await resPositions.json();
    }
    function initializePeriodsCanvas() {
      new p5(function(p) {
        p.setup = function() {
          let canvas = p.createCanvas(40, 292);
          canvas.parent("canvasPeriods");
          let container = document.getElementById("canvasPeriods");
          let bgLeft = parseInt(document.getElementById("canvasTableBackground").style.left);
          container.style.left = (bgLeft + 6) + "px";
          container.style.top = positions[currentMode]["1"].y + "px";
          p.noStroke();
          p.textAlign(p.CENTER, p.CENTER);
          p.textSize(11);
          p.textStyle(p.BOLD);
          const periodLabels = ["1η K", "2η L", "3η M", "4η N", "5η O", "6η Ρ", "7η Q"];
          for (let i = 0; i < 7; i++) {
            p.fill(240);
            p.rect(0, i * 42, 40, 40);
            p.fill(0);
            p.text(periodLabels[i], 20, i * 42 + 20);
          }
        };
      });
    }
    function initGroupsCanvases() {
      new p5(function(p) {
        p.setup = function() {
          let canvas = p.createCanvas(82, 40);
          canvas.parent("canvasS_groups");
          p.background(240);
          for (let col = 0; col < 2; col++) {
            p.noStroke();
            p.noFill();
            p.rect(col * 42, 0, 40, 20);
            p.rect(col * 42, 20, 40, 20);
          }
          p.noStroke();
          p.fill(0);
          p.textAlign(p.CENTER, p.CENTER);
          p.textSize(11);
          p.textStyle(p.BOLD);
          p.text("1", 20, 10);
          p.text("2", 20 + 42, 10);
          p.text("IA", 20, 30);
          p.text("IIA", 20 + 42, 30);
        };
      });
      new p5(function(p) {
        p.setup = function() {
          let canvas = p.createCanvas(418, 40);
          canvas.parent("canvasD_groups");
          p.background(240);
          for (let col = 0; col < 10; col++) {
            p.noStroke();
            p.noFill();
            p.rect(col * 42, 0, 40, 20);
            p.rect(col * 42, 20, 40, 20);
          }
          p.noStroke();
          p.fill(0);
          p.textAlign(p.CENTER, p.CENTER);
          p.textSize(11);
          p.textStyle(p.BOLD);
          for (let c = 0; c < 10; c++) {
            let x = c * 42;
            p.text((c + 3).toString(), x + 20, 10);
          }
          const oldLabels = ["IIIB", "IVB", "VB", "VIB", "VIIB", "VIIIB", "VIIIB", "VIIIB", "IB", "IIB"];
          for (let c = 0; c < 10; c++) {
            let x = c * 42;
            p.text(oldLabels[c], x + 20, 30);
          }
        };
      });
      new p5(function(p) {
        p.setup = function() {
          let canvas = p.createCanvas(250, 40);
          canvas.parent("canvasP_groups");
          p.background(240);
          for (let col = 0; col < 6; col++) {
            p.noStroke();
            p.noFill();
            p.rect(col * 42, 0, 40, 20);
            p.rect(col * 42, 20, 40, 20);
          }
          p.noStroke();
          p.fill(0);
          p.textAlign(p.CENTER, p.CENTER);
          p.textSize(11);
          p.textStyle(p.BOLD);
          for (let c = 0; c < 6; c++) {
            let x = c * 42;
            p.text((c + 13).toString(), x + 20, 10);
          }
          const oldLabels = ["IIIA", "IVA", "VA", "VIA", "VIIA", "VIIIA"];
          for (let c = 0; c < 6; c++) {
            let x = c * 42;
            p.text(oldLabels[c], x + 20, 30);
          }
        };
      });
      ["S", "D", "P"].forEach(sector => {
        let sectorCanvas = document.getElementById("canvas" + sector);
        let groupCanvas = document.getElementById("canvas" + sector + "_groups");
        groupCanvas.style.left = sectorCanvas.style.left;
        groupCanvas.style.top = (parseInt(positions[currentMode]["1"].y) - 42 - 2) + "px";
      });
    }
    function buildInfoPanelTable(currentElement) {
      let prev = getPrevElement(currentElement);
      let curr = currentElement;
      let next = getNextElement(currentElement);
      function buildRow(element) {
         if (!element) {
           return `<tr>
                    <td colspan="2" style="text-align:center; font-size:16px;">-</td>
                   </tr>
                   <tr>
                    <td colspan="2" style="text-align:center; font-size:16px;">-</td>
                   </tr>`;
         } else {
           let color = textColors[element.block] || "#CCCCCC";
           let numberContent = `<span style="color:${color};">Ζ=${element.number}</span>`;
           let subshellContent = `<span style="color:${color}; font-size:14px; text-align:left;">${element.subshells || "-"}</span>`;
           let stacksContent = `<span style="color:${color}; font-size:14px; text-align:left;">${formatShells(element, true) || "-"}</span>`;
           let messageContent = `<span style="color:${color}; font-size:14px; text-align:left;">${messageForElement(element) || "-"}</span>`;
           return `<tr>
                     <td style="white-space: nowrap; text-align:left; font-size:16px;">${numberContent}</td>
                     <td style="white-space: nowrap; text-align:left; font-size:14px;">${subshellContent}</td>
                     <td style="white-space: nowrap; text-align:left; font-size:14px;">${stacksContent}</td>
                     <td style="white-space: nowrap; text-align:left; font-size:14px;">${messageContent}</td>
                   </tr>`;
         }
      }
      let gapRow = `<tr style="height:4px;"><td colspan="4"></td></tr>`;
      let rows = buildRow(prev) + gapRow + buildRow(curr) + gapRow + buildRow(next);
      return `<table style="width:100%; border-collapse:collapse; line-height:1;">${rows}</table>`;
    }
    function adjustFontSize(container, maxFontSize) {
      let fontSize = maxFontSize;
      container.style.fontSize = fontSize + "px";
      while (container.scrollWidth > container.clientWidth && fontSize > 8) {
         fontSize -= 1;
         container.style.fontSize = fontSize + "px";
      }
    }
    function getPrevElement(currentElement) {
      let currPos = currentCellPositions[currentElement.number];
      if (!currPos) return null;
      let currCenterX = currPos.x + currPos.width / 2;
      let currCenterY = currPos.y + currPos.height / 2;
      let candidates = [];
      for (let e of elements) {
        if (e.number == currentElement.number) continue;
        if (!(e.number in currentCellPositions)) continue;
        let pos = currentCellPositions[e.number];
        let centerX = pos.x + pos.width / 2;
        let centerY = pos.y + pos.height / 2;
        if (centerY < currCenterY && Math.abs(centerX - currCenterX) < 1) {
          candidates.push({ e, centerY });
        }
      }
      if (candidates.length === 0) return null;
      candidates.sort((a, b) => b.centerY - a.centerY);
      return candidates[0].e;
    }
    function getNextElement(currentElement) {
      let currPos = currentCellPositions[currentElement.number];
      if (!currPos) return null;
      let currCenterX = currPos.x + currPos.width / 2;
      let currCenterY = currPos.y + currPos.height / 2;
      let candidates = [];
      for (let e of elements) {
        if (e.number == currentElement.number) continue;
        if (!(e.number in currentCellPositions)) continue;
        let pos = currentCellPositions[e.number];
        let centerX = pos.x + pos.width / 2;
        let centerY = pos.y + pos.height / 2;
        if (Math.abs(centerY - currCenterY) < currPos.height * 0.5 && centerX > currCenterX) {
          candidates.push({ e, centerX });
        }
      }
      if (candidates.length === 0) return null;
      candidates.sort((a, b) => a.centerX - b.centerX);
      return candidates[0].e;
    }
    function getSubshells(element) {
      if (!element) return [];
      if (typeof element.subshells === "string") return element.subshells.split(" ");
      if (Array.isArray(element.subshells)) return element.subshells;
      return [];
    }
    function messageForElement(element) {
      if(element.block === 'f') {
        return (element.row === 6) ? "Λανθανίδα" : "Ακτινίδα";
      } else {
        let group = parseInt(element.col);
        if(group === 1) {
          return (element.number === 1) ? "Θέλει να <strong>πάρει</strong> 1 ηλεκτρόνιο" : "Θέλει να <strong>δώσει</strong> 1 ηλεκτρόνιο";
        } else if(group === 2) {
          return `Θέλει να <strong>δώσει</strong> ${group} ηλεκτρόνια`;
        } else if(group === 13) {
          return `Θέλει να <strong>δώσει</strong> ${group - 10} ηλεκτρόνια`;
        } else if(group >= 3 && group <= 12) {
          return "Στοιχείο μετάπτωσης";
        } else if(group === 14) {
          return "Θέλει να <strong>δώσει</strong> ή να <strong>πάρει</strong> 4 ηλεκτρόνια";
        } else if(group >= 15 && group <= 17) {
          return `Θέλει να <strong>πάρει</strong> ${18 - group} ηλεκτρόνια`;
        } else if(group === 18) {
          return "Ευγενές αέριο-Χημικά αδρανές";
        }
        return "";
      }
    }
    function showBalloonOverlay(elementNumber) {
      let currentElement = elements.find(e => e.number == elementNumber);
      if (!currentElement) return;
      currentBalloonElement = elementNumber;
      let prev = getPrevElement(currentElement);
      let curr = currentElement;
      let next = getNextElement(currentElement);
      let prevColor = prev ? (textColors[prev.block] || "#CCCCCC") : "#CCCCCC";
      let currColor = currentElement ? (textColors[currentElement.block] || "#CCCCCC") : "#CCCCCC";
      let nextColor = next ? (textColors[next.block] || "#CCCCCC") : "#CCCCCC";
      let prevSubshells = prev ? (prev.subshells || "-") : "-";
      let prevShells = prev ? formatShells(prev, true) : "-";
      let currSubshells = currentElement ? (currentElement.subshells || "-") : "-";
      let currShells = currentElement ? formatShells(currentElement, true) : "-";
      let nextSubshells = next ? (next.subshells || "-") : "-";
      let nextShells = next ? formatShells(next, true) : "-";
      
      // Πίνακας του balloon με μειωμένο line-height και gap 4px μεταξύ των στιβάδων
      let tableHTML = `
      <table style="border-collapse: collapse; width:100%; font-size:13px; line-height:1;">
        <tr>
          <td rowspan="2" style="color:${prevColor}; font-weight:bold;">Ζ=${prev ? prev.number : "-"}</td>
          <td style="color:${prevColor}; text-align:left;">${prevSubshells}</td>
        </tr>
        <tr>
          <td style="color:${prevColor}; border-bottom:1px solid #ccc; text-align:left;">${prevShells}</td>
        </tr>
        <tr style="height:4px;"><td colspan="2"></td></tr>
        <tr>
          <td rowspan="2" style="color:${currColor}; font-weight:bold;">Ζ=${currentElement ? currentElement.number : "-"}</td>
          <td style="color:${currColor}; text-align:left;">${currSubshells}</td>
        </tr>
        <tr>
          <td style="color:${currColor}; border-bottom:1px solid #ccc; text-align:left;">${currShells}</td>
        </tr>
        <tr style="height:4px;"><td colspan="2"></td></tr>
        <tr>
          <td rowspan="2" style="color:${nextColor}; font-weight:bold;">Ζ=${next ? next.number : "-"}</td>
          <td style="color:${nextColor}; text-align:left;">${nextSubshells}</td>
        </tr>
        <tr>
          <td style="color:${nextColor}; text-align:left;">${nextShells}</td>
        </tr>
      </table>
      `;
      
      let overlay = document.getElementById("balloonOverlay");
      overlay.innerHTML = tableHTML;
      let cellPos = currentCellPositions[elementNumber];
      if (!cellPos) return;
      overlay.style.visibility = "visible";
      overlay.style.opacity = "0";
      setTimeout(() => { overlay.style.opacity = "0.96"; }, 10);
      let overlayRect = overlay.getBoundingClientRect();
      let overlayWidth = overlayRect.width;
      let cellRight = cellPos.x + cellPos.width;
      let screenHalf = window.innerWidth / 2;
      let overlayX = (cellRight > screenHalf) ? (cellPos.x + cellPos.width - (overlayWidth + 22)) : (cellPos.x + cellPos.width - 5);
      let overlayY = cellPos.y + cellPos.height - 5;
      // Αν το balloon σε expanded mode επικαλύπτει τον info panel, μετατοπίζεται προς τα κάτω κατά (ύψος balloon + 22px)
      if (currentMode === "expanded") {
         let infoPanelRect = document.getElementById("infoPanelFull").getBoundingClientRect();
         if (overlayRect.top < infoPanelRect.bottom) {
           overlayY = overlayY + overlayRect.height + 22;
         }
      }
      overlay.style.left = overlayX + "px";
      overlay.style.top = overlayY + "px";
      overlay.style.fontSize = "13px";
      sectorInstances.forEach(inst => {
        if (typeof inst.myRedraw === "function") inst.myRedraw();
      });
      updateInfo();
    }
    function switchToCollapsed() {
      let infoFull = document.getElementById("infoPanelFull");
      let infoCollapsed = document.getElementById("infoPanelCollapsed");
      let bgRect = document.getElementById("canvasTableBackground").getBoundingClientRect();
      let targetLeft = bgRect.right + 20;
      let targetWidth = window.innerWidth - bgRect.width - 200;
      let targetTop = positions["collapsed"] && positions["collapsed"]["1"] ? positions["collapsed"]["1"].y : 55;
      infoFull.style.left = targetLeft + "px";
      infoFull.style.top = targetTop + "px";
      infoFull.style.width = targetWidth + "px";
      setTimeout(() => {
        infoFull.style.display = "none";
        infoCollapsed.style.display = "block";
        infoCollapsed.style.opacity = "1";
      }, 500);
    }
    function switchToExpanded() {
      let infoFull = document.getElementById("infoPanelFull");
      let infoCollapsed = document.getElementById("infoPanelCollapsed");
      let bgRect = document.getElementById("canvasTableBackground").getBoundingClientRect();
      let collapsedLeft = bgRect.right + 20;
      let collapsedWidth = window.innerWidth - bgRect.width - 200;
      let collapsedTop = positions["collapsed"] && positions["collapsed"]["1"] ? positions["collapsed"]["1"].y : 55;
      infoFull.style.left = collapsedLeft + "px";
      infoFull.style.top = collapsedTop + "px";
      infoFull.style.width = collapsedWidth + "px";
      infoCollapsed.style.display = "none";
      infoFull.style.display = "block";
      infoFull.style.opacity = "1";
      let btnRect = document.getElementById("buttonPanel").getBoundingClientRect();
      let targetLeft = 20;
      let targetWidth = window.innerWidth - 207;
      let targetTop = btnRect.top;
      setTimeout(() => {
        infoFull.style.left = targetLeft + "px";
        infoFull.style.top = targetTop + "px";
        infoFull.style.width = targetWidth + "px";
      }, 10);
    }
    function updateInfo() {
      let currentElement = elements.find(e => e.number == (currentBalloonElement || "3"));
      if (!currentElement) return;
      let leftHTML = `<span style="font-size:1.3em; font-weight:bold; color:${textColors[currentElement.block]};">Ζ=${currentElement.number}</span> 
                      <span style="font-size:3em; font-weight:bold; color:${textColors[currentElement.block]};">
                        ${currentElement.symbol || ""}</span> 
                      <span style="font-style: italic; color:${textColors[currentElement.block]};">${currentElement.name || ""}</span>`;
      let subshellsHTML = buildInfoPanelTable(currentElement);
      let remarksHTML = `<div style="text-align:center; font-style:italic; margin-top:10px; font-size:14px;">${currentElement.remarks || ""}</div>`;
      let infoPanelFull = document.getElementById("infoPanelFull");
      document.getElementById("infoLeft").innerHTML = leftHTML;
      document.getElementById("infoSubshells").innerHTML = subshellsHTML;
      document.getElementById("infoRemarks").innerHTML = remarksHTML;
      infoPanelFull.style.width = (window.innerWidth - 207) + "px";
      let btnRect = document.getElementById("buttonPanel").getBoundingClientRect();
      infoPanelFull.style.top = btnRect.top + "px";
      adjustFontSize(document.getElementById("infoSubshells"), 16);
      
      if (currentMode === "collapsed") {
        let infoPanelCollapsed = document.getElementById("infoPanelCollapsed");
        let bgRect = document.getElementById("canvasTableBackground").getBoundingClientRect();
        infoPanelCollapsed.style.left = (bgRect.right + 20) + "px";
        if (positions[currentMode] && positions[currentMode]["1"]) {
          infoPanelCollapsed.style.top = positions[currentMode]["1"].y + "px";
        }
        let collapsedWidth = window.innerWidth - bgRect.width - 200 + 126 - 10;
        infoPanelCollapsed.style.width = collapsedWidth + "px";
        infoPanelCollapsed.style.height = "auto";
        
        let basicInfo = leftHTML;
        let prev = getPrevElement(currentElement);
        let curr = currentElement;
        let next = getNextElement(currentElement);
        let prevSubshell = prev ? `<div style="text-align:left; font-size:14px; color:${textColors[prev.block]};">${prev.subshells || "-"}</div>` : `<div style="text-align:left; font-size:14px;">-</div>`;
        let currSubshell = `<div style="text-align:left; font-size:14px; color:${textColors[curr.block]};">${curr.subshells || "-"}</div>`;
        let nextSubshell = next ? `<div style="text-align:left; font-size:14px; color:${textColors[next.block]};">${next.subshells || "-"}</div>` : `<div style="text-align:left; font-size:14px;">-</div>`;
        let prevStacks = prev ? `<div style="text-align:left; font-size:14px; color:${textColors[prev.block]};">${formatShells(prev, true) || "-"}</div>` : `<div style="text-align:left; font-size:14px;">-</div>`;
        let currStacks = `<div style="text-align:left; font-size:14px; color:${textColors[curr.block]};">${formatShells(curr, true) || "-"}</div>`;
        let nextStacks = next ? `<div style="text-align:left; font-size:14px; color:${textColors[next.block]};">${formatShells(next, true) || "-"}</div>` : `<div style="text-align:left; font-size:14px;">-</div>`;
        let prevMsg = prev ? `<div style="text-align:left; font-size:14px; color:${textColors[prev.block]};">${messageForElement(prev) || "-"}</div>` : `<div style="text-align:left; font-size:14px;">-</div>`;
        let currMsg = `<div style="text-align:left; font-size:14px; color:${textColors[curr.block]};">${messageForElement(curr) || "-"}</div>`;
        let nextMsg = next ? `<div style="text-align:left; font-size:14px; color:${textColors[next.block]};">${messageForElement(next) || "-"}</div>` : `<div style="text-align:left; font-size:14px;">-</div>`;
        let remarksBlock = `<div style="text-align:center; font-style:italic; font-size:14px;">${currentElement.remarks || ""}</div>`;
        
        let collapsedHTML = `
          ${basicInfo}
          <hr>
          ${prevSubshell}
          ${currSubshell}
          ${nextSubshell}
          <hr>
          ${prevStacks}
          ${currStacks}
          ${nextStacks}
          <hr>
          ${prevMsg}
          ${currMsg}
          ${nextMsg}
          <hr>
          ${remarksBlock}
        `;
        infoPanelCollapsed.innerHTML = collapsedHTML;
        adjustFontSize(document.getElementById("infoPanelCollapsed"), 16);
      }
    }
    function drawElements(p, block, containerLeft, containerTop) {
      let colors = { s: "#FF477E", p: "#26FF31", d: "#3F99FF", f: "#FFD051" };
      elements.filter(e => e.block === block).forEach(e => {
        let num = Number(e.number);
        if (currentMode === "start") {
          if ((num < 3 && !extraElements[num]) || num > currentZ) return;
        }
        let pos = positions[currentMode][e.number] ||
                  ((e.number === "1" || e.number === "2") ? positions["start"][e.number] : null);
        if (pos) {
          let relativeX = pos.x - containerLeft;
          let relativeY = pos.y - containerTop;
          if (currentMode === "start") {
            if (block === "p" && num >= 21 && num <= 30)
              relativeY += getShift(num, block);
            else if ((block === "p" || block === "d") && num >= 57 && num <= 70)
              relativeY += getShift(num, block);
          }
          if (currentBalloonElement == e.number) {
              p.strokeWeight(3);
              p.stroke(0);
          } else {
              p.noStroke();
          }
          p.fill(colors[block] || "#CCCCCC");
          p.rect(relativeX, relativeY, pos.width, pos.height, 5);
          p.noStroke();
          p.fill(0);
          p.textSize(13);
          p.textStyle(p.BOLD);
          p.textAlign(p.CENTER, p.CENTER);
          p.text(e.number, relativeX + pos.width / 2, relativeY + pos.height / 2);
        }
      });
    }
    function performHitTest(x, y) {
      let region = computeModeRegionUpdated();
      if (!region) {
         console.log("Δεν εμφανίζονται στοιχεία στο τρέχον mode.");
         return null;
      }
      let regionLeft = region.minX, regionTop = region.minY;
      if (x < regionLeft || x > region.maxX || y < regionTop) {
         console.log("Κλικ εκτός περιοχής στοιχείων.");
         return null;
      }
      let relX = x - regionLeft, relY = y - regionTop;
      let offCanvas = document.getElementById("offscreenCanvas");
      offCanvas.width = region.maxX - region.minX;
      offCanvas.height = region.maxY - region.minY;
      let offCtx = offCanvas.getContext("2d");
      offCtx.clearRect(0, 0, offCanvas.width, offCanvas.height);
      for (let key in currentCellPositions) {
         let pos = currentCellPositions[key];
         let drawX = pos.x - regionLeft;
         let drawY = pos.y - regionTop;
         let num = Number(key);
         let r = (num * 37) % 256;
         let g = (num * 67) % 256;
         let b = (num * 97) % 256;
         offCtx.fillStyle = "rgb(" + r + "," + g + "," + b + ")";
         offCtx.fillRect(drawX, drawY, pos.width, pos.height);
      }
      let pixel = offCtx.getImageData(relX, relY, 1, 1).data;
      if (pixel[3] === 0) {
         console.log("Δεν ανιχνεύτηκε στοιχείο στο σημείο (" + x + ", " + y + ") μέσω color picking.");
         return null;
      } else {
         for (let key in currentCellPositions) {
            let pos = currentCellPositions[key];
            let num = Number(key);
            let r = (num * 37) % 256;
            let g = (num * 67) % 256;
            let b = (num * 97) % 256;
            if (pixel[0] === r && pixel[1] === g && pixel[2] === b) {
                return key;
            }
         }
         return null;
      }
    }
    window.initializeSectorsCanvas = function() {
      sectorInstances = [];
      let blocks = ["s", "p", "d", "f"];
      blocks.forEach(block => {
        let container = document.getElementById("canvas" + block.toUpperCase());
        container.innerHTML = "";
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        elements.filter(e => e.block === block).forEach(e => {
          let num = Number(e.number);
          if (currentMode === "start") {
            if ((num < 3 && !extraElements[num]) || num > currentZ) return;
          }
          let pos = positions[currentMode][e.number] ||
                    ((e.number === "1" || e.number === "2") ? positions["start"][e.number] : null);
          if (pos) {
            let yForMin = pos.y, yForMax = pos.y;
            if (currentMode === "start") {
              if (block === "p" && num >= 21 && num <= 30) yForMax += getShift(num, block);
              else if ((block === "p" || block === "d") && num >= 57 && num <= 70) yForMax += getShift(num, block);
            }
            minX = Math.min(minX, pos.x);
            minY = Math.min(minY, yForMin);
            maxX = Math.max(maxX, pos.x + pos.width);
            maxY = Math.max(maxY, yForMax + pos.height);
          }
        });
        if (minX === Infinity || minY === Infinity) return;
        if (currentMode === "start" && (block === "p" || block === "d"))
          container.style.left = (minX + getShiftContainer(block)) + "px";
        else
          container.style.left = minX + "px";
        container.style.top = minY + "px";
        container.style.width = (maxX - minX) + "px";
        container.style.height = (maxY - minY) + "px";
        let inst = new p5(function(p) {
          p.setup = function() {
            let canvas = p.createCanvas(parseInt(container.style.width), parseInt(container.style.height));
            canvas.parent("canvas" + block.toUpperCase());
            p.noLoop();
            drawElements(p, block, minX, minY);
          };
          p.myRedraw = function() {
            p.clear();
            drawElements(p, block, minX, minY);
          };
        });
        sectorInstances.push(inst);
      });
    };
    function fillAllAction() {
      document.querySelectorAll('.canvas').forEach(el => el.innerHTML = '');
      currentMode = "expanded";
      currentZ = 123;
      initializeBackgroundCanvas();
      window.initializeSectorsCanvas();
      initializePeriodsCanvas();
      initGroupsCanvases();
      document.getElementById('toggleFBlock').disabled = false;
      updateCellsPositions();
      updateInfo();
    }
    document.getElementById('fillAll').addEventListener('click', function() { fillAllAction(); });
    document.getElementById('toggleFBlock').addEventListener('click', function() {
      isCollapsed = !isCollapsed;
      this.textContent = isCollapsed ? "Ανάπτυξε" : "Σύμπτυξε";
      if (isCollapsed) {
        currentMode = "collapsed";
        switchToCollapsed();
      } else {
        currentMode = "expanded";
        switchToExpanded();
      }
      document.getElementById("infoPanelFull").style.display = (currentMode === "expanded") ? "block" : "none";
      document.getElementById("infoPanelCollapsed").style.display = (currentMode === "collapsed") ? "block" : "none";
      initializeBackgroundCanvas();
      window.initializeSectorsCanvas();
      ["S", "D", "P"].forEach(sector => {
        let sectorCanvas = document.getElementById("canvas" + sector);
        let groupCanvas = document.getElementById("canvas" + sector + "_groups");
        groupCanvas.style.left = sectorCanvas.style.left;
        groupCanvas.style.top = (parseInt(positions[currentMode]["1"].y) - 42 - 2) + "px";
      });
      updateCellsPositions();
      setTimeout(() => {
        updateCellsPositions();
        if (currentBalloonElement !== null && currentCellPositions[currentBalloonElement]) {
          showBalloonOverlay(currentBalloonElement);
        }
        updateInfo();
      }, 1300);
    });
    document.getElementById('nextState').addEventListener('click', function() {
      if (currentMode !== "start") {
        console.log("Το κουμπί 'Επόμενο' λειτουργεί μόνο στην κατάσταση 'start'. Κάντε Reset για επαναφορά.");
        return;
      }
      if (currentZ < 118) {
        currentZ++;
      } else if (currentZ === 118) {
        currentZ = 119;
        extraElements["1"] = true;
      } else if (currentZ === 119) {
        currentZ = 120;
        extraElements["2"] = true;
      } else if (currentZ === 120) {
        currentZ = 121;
        showPeriods = true;
      } else if (currentZ === 121) {
        fillAllAction();
        return;
      }
      initializeBackgroundCanvas();
      window.initializeSectorsCanvas();
      if (showPeriods) initializePeriodsCanvas();
      updateCellsPositions();
      if (currentCellPositions[currentZ]) {
         showBalloonOverlay(currentZ);
      }
      updateInfo();
    });
    document.getElementById('reset').addEventListener('click', function() {
      currentMode = "start";
      currentZ = 3;
      extraElements = {};
      showPeriods = false;
      location.reload();
    });
    window.addEventListener("resize", function(){
      if (currentBalloonElement !== null && currentCellPositions[currentBalloonElement]) {
        showBalloonOverlay(currentBalloonElement);
      }
    });
    function initializeCanvases() {
      Object.keys({ s: 1, p: 1, d: 1, f: 1 }).forEach(function(block) {
        new p5(function(p) {
          p.setup = function() {
            let config = { cols: 10, rows: 7 };
            if (block === "s") config = { cols: 2, rows: 7 };
            else if (block === "p") config = { cols: 6, rows: 7 };
            else if (block === "d") config = { cols: 10, rows: 7 };
            else if (block === "f") config = { cols: 14, rows: 7 };
            let canvas = p.createCanvas(config.cols * cellSize, config.rows * cellSize);
            canvas.elt.getContext("2d", { willReadFrequently: true });
            canvas.parent("canvas" + block.toUpperCase());
            p.skipNextClick = true;
            setTimeout(() => { p.skipNextClick = false; }, 100);
            p.mouseClicked = function(event) {
              if (p.skipNextClick) return;
              let globalX = event.clientX;
              let globalY = event.clientY;
              let found = performHitTest(globalX, globalY);
              if (found !== null) {
                showBalloonOverlay(found);
              }
            };
            window.drawElements(p, block);
          };
        });
      });
    }
    window.drawElements = drawElements;
    function performHitTest(x, y) {
      let region = computeModeRegionUpdated();
      if (!region) {
         console.log("Δεν εμφανίζονται στοιχεία στο τρέχον mode.");
         return null;
      }
      let regionLeft = region.minX, regionTop = region.minY;
      if (x < regionLeft || x > region.maxX || y < regionTop) {
         console.log("Κλικ εκτός περιοχής στοιχείων.");
         return null;
      }
      let relX = x - regionLeft, relY = y - regionTop;
      let offCanvas = document.getElementById("offscreenCanvas");
      offCanvas.width = region.maxX - region.minX;
      offCanvas.height = region.maxY - region.minY;
      let offCtx = offCanvas.getContext("2d");
      offCtx.clearRect(0, 0, offCanvas.width, offCanvas.height);
      for (let key in currentCellPositions) {
         let pos = currentCellPositions[key];
         let drawX = pos.x - regionLeft;
         let drawY = pos.y - regionTop;
         let num = Number(key);
         let r = (num * 37) % 256;
         let g = (num * 67) % 256;
         let b = (num * 97) % 256;
         offCtx.fillStyle = "rgb(" + r + "," + g + "," + b + ")";
         offCtx.fillRect(drawX, drawY, pos.width, pos.height);
      }
      let pixel = offCtx.getImageData(relX, relY, 1, 1).data;
      if (pixel[3] === 0) {
         console.log("Δεν ανιχνεύτηκε στοιχείο στο σημείο (" + x + ", " + y + ") μέσω color picking.");
         return null;
      } else {
         for (let key in currentCellPositions) {
            let pos = currentCellPositions[key];
            let num = Number(key);
            let r = (num * 37) % 256;
            let g = (num * 67) % 256;
            let b = (num * 97) % 256;
            if (pixel[0] === r && pixel[1] === g && pixel[2] === b) {
                return key;
            }
         }
         return null;
      }
    }
    window.initializeSectorsCanvas = function() {
      sectorInstances = [];
      let blocks = ["s", "p", "d", "f"];
      blocks.forEach(block => {
        let container = document.getElementById("canvas" + block.toUpperCase());
        container.innerHTML = "";
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        elements.filter(e => e.block === block).forEach(e => {
          let num = Number(e.number);
          if (currentMode === "start") {
            if ((num < 3 && !extraElements[num]) || num > currentZ) return;
          }
          let pos = positions[currentMode][e.number] ||
                    ((e.number === "1" || e.number === "2") ? positions["start"][e.number] : null);
          if (pos) {
            let yForMin = pos.y, yForMax = pos.y;
            if (currentMode === "start") {
              if (block === "p" && num >= 21 && num <= 30) yForMax += getShift(num, block);
              else if ((block === "p" || block === "d") && num >= 57 && num <= 70) yForMax += getShift(num, block);
            }
            minX = Math.min(minX, pos.x);
            minY = Math.min(minY, yForMin);
            maxX = Math.max(maxX, pos.x + pos.width);
            maxY = Math.max(maxY, yForMax + pos.height);
          }
        });
        if (minX === Infinity || minY === Infinity) return;
        if (currentMode === "start" && (block === "p" || block === "d"))
          container.style.left = (minX + getShiftContainer(block)) + "px";
        else
          container.style.left = minX + "px";
        container.style.top = minY + "px";
        container.style.width = (maxX - minX) + "px";
        container.style.height = (maxY - minY) + "px";
        let inst = new p5(function(p) {
          p.setup = function() {
            let canvas = p.createCanvas(parseInt(container.style.width), parseInt(container.style.height));
            canvas.parent("canvas" + block.toUpperCase());
            p.noLoop();
            drawElements(p, block, minX, minY);
          };
          p.myRedraw = function() {
            p.clear();
            drawElements(p, block, minX, minY);
          };
        });
        sectorInstances.push(inst);
      });
    };
    loadData().then(() => {
      if (currentMode === "expanded" || currentMode === "collapsed") {
        initializeBackgroundCanvas();
        window.initializeSectorsCanvas();
        initializePeriodsCanvas();
        initGroupsCanvases();
        initializeCanvases();
      } else if (currentMode === "start") {
        initializeBackgroundCanvas();
        window.initializeSectorsCanvas();
        initializeCanvases();
      }
      updateCellsPositions();
      if (currentMode === "start" && currentCellPositions[3]) {
        showBalloonOverlay(3);
      }
      updateInfo();
    });
  </script>
</body>
</html>
