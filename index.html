<!DOCTYPE html>
<html lang="el">
<head>
  <meta charset="UTF-8">
  <title>Περιοδικός Πίνακας με Complex Balloon Overlay</title>
  <link href="https://fonts.googleapis.com/css?family=Roboto&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
  <style>
    body { 
      font-family: 'Roboto', sans-serif;
      margin: 0; 
      overflow: hidden; 
      background: #f7f7f7; 
    }
    .canvas { 
      position: absolute; 
      background: transparent; 
      transition: all 0.5s ease-in-out;
    }
    canvas {
      padding: 8px;
      filter: drop-shadow(4px 4px 4px rgba(0,0,0,0.5));
      overflow: visible;
    }
    /* Background canvas */
    #canvasTableBackground {
      position: absolute; 
      background: white; 
      border: 1px solid rgba(0,0,0,0.1);
      box-shadow: 6px 6px 10px rgba(0,0,0,0.3); 
      z-index: -10;
      opacity: 1;
      transition: all 0.5s ease-in-out;
    }
    /* Group canvases */
    #canvasS_groups, #canvasD_groups, #canvasP_groups { 
      position: absolute; 
      z-index: 60;
    }
    /* Sector canvases */
    #canvasS { z-index: 10; }
    #canvasF { z-index: 20; }
    #canvasD { z-index: 30; }
    #canvasP { z-index: 40; }
    #canvasPeriods { z-index: 50; }
    /* Button panel */
    #buttonPanel {
      position: fixed; 
      bottom: 20px; 
      right: 20px;
      z-index: 100;
      display: flex; 
      flex-direction: column;
      gap: 5px;
    }
    #buttonPanel button {
      background-color: #008CBA; 
      color: white;
      padding: 10px 15px;
      border: none; 
      border-radius: 5px;
      cursor: pointer;
      box-shadow: 4px 4px 4px rgba(0,0,0,0.5);
    }
    /* Offscreen canvas */
    #offscreenCanvas { display: none; }
    /* Balloon overlay */
    #balloonOverlay {
      position: absolute;
      background: white;
      border: 1px solid rgba(0,0,0,0.2);
      box-shadow: 2px 2px 6px rgba(0,0,0,0.3);
      padding: 6px 8px;
      border-radius: 5px;
      z-index: 150;
      visibility: hidden;
      opacity: 0;
      transition: opacity 0.3s ease;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <!-- Καμβάδες -->
  <div id="canvasTableBackground"></div>
  <div id="canvasS_groups" class="canvas"></div>
  <div id="canvasD_groups" class="canvas"></div>
  <div id="canvasP_groups" class="canvas"></div>
  
  <div id="canvasPeriods" class="canvas"></div>
  <div id="canvasS" class="canvas"></div>
  <div id="canvasD" class="canvas"></div>
  <div id="canvasP" class="canvas"></div>
  <div id="canvasF" class="canvas"></div>

  <!-- Κουμπιά -->
  <div id="buttonPanel">
    <button id="nextState">Επόμενο</button>
    <button id="fillAll">Συμπλήρωσε</button>
    <button id="toggleFBlock" disabled>Σύμπτυξε</button>
    <button id="reset">Reset</button>
  </div>
  
  <!-- Offscreen canvas -->
  <canvas id="offscreenCanvas" width="800" height="600"></canvas>
  
  <!-- Balloon overlay -->
  <div id="balloonOverlay"></div>

  <script>
    // Global variables
    let elements = [];
    let positions = {};
    let isCollapsed = false;
    let currentMode = "start";
    let currentZ = 3;
    let extraElements = {};
    let showPeriods = false;
    let cellSize = 40;
    let currentCellPositions = {};
    let currentBalloonElement = null;
    let selectedElement = null; // Το επιλεγμένο κελί

    /* --- Global helper functions --- */
    // Επιστρέφει τους υποστιβάδες ως πίνακα
    function getSubshells(element) {
      if (!element) return [];
      if (typeof element.subshells === "string") return element.subshells.split(" ");
      if (Array.isArray(element.subshells)) return element.subshells;
      return [];
    }
    
    function shellLetter(n) {
      let mapping = { "1": "K", "2": "L", "3": "M", "4": "N", "5": "O", "6": "P" };
      return mapping[n] || n;
    }
    
    function formatSubshell(subshell) {
      let match = subshell.match(/^(\d+)[a-zA-Z]+(\d+)/);
      if(match){
         let principal = match[1];
         let count = match[2];
         return shellLetter(principal) + "(" + count + ")";
      }
      return subshell;
    }
    
    function getFormattedLine(element, isCurrent) {
      let subs = getSubshells(element);
      let formattedArr = subs.map(subshell => formatSubshell(subshell));
      if(formattedArr.length > 0) {
         // Σε κάθε περίπτωση, μόνο η τελευταία υποστιβάδα είναι bold για όλα τα στοιχεία
         formattedArr[formattedArr.length - 1] = "<b>" + formattedArr[formattedArr.length - 1] + "</b>";
      }
      return formattedArr.join(" ");
    }
    
    /* --- Βοηθητικές συναρτήσεις εύρεσης στοιχείων --- */
    function getPrevElement(currentElement) {
      let prev = elements.find(e => e.col == currentElement.col && e.block == currentElement.block && e.row == currentElement.row - 1);
      if(prev) return prev;
      let candidates = elements.filter(e => e.col == currentElement.col && e.block == currentElement.block && e.row < currentElement.row);
      if(candidates.length > 0) {
         candidates.sort((a, b) => b.row - a.row);
         return candidates[0];
      }
      return null;
    }
    
    function getNextElement(currentElement) {
      let next = elements.find(e => e.col == currentElement.col && e.block == currentElement.block && e.row == currentElement.row + 1);
      if(next) return next;
      let candidates = elements.filter(e => e.col == currentElement.col && e.block == currentElement.block && e.row > currentElement.row);
      if(candidates.length > 0) {
         candidates.sort((a, b) => a.row - b.row);
         return candidates[0];
      }
      return null;
    }
    
    /* --- Συναρτήσεις σχεδίασης --- */
    // Εμφανίζει τα στοιχεία σε κάθε p5 καμβά
    function drawElements(p, block, containerLeft, containerTop) {
      let colors = { s: "#FF477E", p: "#26FF31", d: "#3F99FF", f: "#FFD051" };
      p.clear();
      elements.filter(e => e.block === block).forEach(e => {
        let num = Number(e.number);
        if (currentMode === "start") {
          if ((num < 3 && !extraElements[num]) || num > currentZ) return;
        }
        let pos = positions[currentMode][e.number] ||
                  ((e.number === "1" || e.number === "2") ? positions["start"][e.number] : null);
        if (pos) {
          let relativeX = pos.x - containerLeft;
          let relativeY = pos.y - containerTop;
          if (currentMode === "start") {
            if (block === "p" && num >= 21 && num <= 30)
              relativeY += getShift(num, block);
            else if ((block === "p" || block === "d") && num >= 57 && num <= 70)
              relativeY += getShift(num, block);
          }
          // Αν αυτό το στοιχείο είναι επιλεγμένο, σχεδιάζουμε περίγραμμα
          if (e.number == selectedElement) {
            p.stroke(0);
            p.strokeWeight(3);
          } else {
            p.noStroke();
          }
          p.fill(colors[block] || "#CCCCCC");
          p.rect(relativeX, relativeY, pos.width, pos.height, 5);
          p.noStroke();
          p.fill(0);
          p.textSize(13);
          p.textStyle(p.BOLD);
          p.textAlign(p.CENTER, p.CENTER);
          p.text(e.number, relativeX + pos.width / 2, relativeY + pos.height / 2);
        }
      });
    }
    
    // Δημιουργεί μία γραμμή του πίνακα του balloon για ένα στοιχείο.
    // Εάν το στοιχείο δεν υπάρχει, εμφανίζει "-" στα δύο κελιά.
    function rowHTML(element, isCurrent) {
      if(!element) {
        return `<div style="display: table-row;">
                  <div style="display: table-cell; vertical-align: top; padding:2px; min-width:50px; border-right:1px solid lightgray;">-</div>
                  <div style="display: table-cell; vertical-align: top; padding:2px;">
                    <div style="font-size:11px; line-height:1;">-</div>
                    <div style="font-size:11px; line-height:1;">-</div>
                  </div>
                </div>`;
      }
      let atomicNumber = element.number;
      let leftCell = isCurrent 
         ? `<div style="font-size:11px; font-weight:bold; min-width:50px;">Ζ=${atomicNumber}</div>` 
         : `<div style="font-size:11px; min-width:50px;">Ζ=${atomicNumber}</div>`;
      let rawHTML = `<div style="font-size:11px; line-height:1;">${getSubshells(element).join(" ")}</div>`;
      let formattedHTML = `<div style="font-size:11px; line-height:1;">${getFormattedLine(element, isCurrent)}</div>`;
      let rightCell = `<div style="display: table-cell; vertical-align: top; padding:2px;">${rawHTML}${formattedHTML}</div>`;
      return `<div style="display: table-row;">${leftCell}${rightCell}</div>`;
    }
    
    // Κύρια συνάρτηση εμφάνισης του balloon overlay.
    // Δημιουργεί πίνακα 3 γραμμών για: το στοιχείο από πάνω, το τρέχον, και το επόμενο (ή δίπλα).
    function showBalloonOverlay(elementNumber) {
      let currentElement = elements.find(e => e.number == elementNumber);
      if (!currentElement) return;
      currentBalloonElement = elementNumber;
      selectedElement = elementNumber; // Ενημέρωση επιλεγμένου κελιού
      let prevElement = getPrevElement(currentElement);
      let nextElement = getNextElement(currentElement);
      let tableHTML = `<div style="display: table; border-collapse: collapse;">`
                      + rowHTML(prevElement, false)
                      + rowHTML(currentElement, true)
                      + rowHTML(nextElement, false)
                      + `</div>`;
      let overlay = document.getElementById("balloonOverlay");
      overlay.innerHTML = tableHTML;
      
      let cellPos = currentCellPositions[elementNumber];
      if (!cellPos) return;
      overlay.style.visibility = "visible";
      overlay.style.opacity = "0";
      let overlayRect = overlay.getBoundingClientRect();
      let overlayWidth = overlayRect.width;
      let overlayHeight = overlayRect.height;
      let cellRight = cellPos.x + cellPos.width;
      let screenHalf = window.innerWidth / 2;
      let overlayX, overlayY;
      if (cellRight > screenHalf) {
         overlayX = cellPos.x + cellPos.width - (overlayWidth + 22);
      } else {
         overlayX = cellPos.x + cellPos.width - 5;
      }
      overlayY = cellPos.y + cellPos.height - 5;
      overlay.style.left = overlayX + "px";
      overlay.style.top = overlayY + "px";
      
      setTimeout(() => { overlay.style.opacity = "1"; }, 10);
    }
    
    // Ενημέρωση θέσης του balloon όταν αλλάζει το μέγεθος του παραθύρου ή κατάσταση
    window.addEventListener("resize", function(){
      if(currentBalloonElement !== null && currentCellPositions[currentBalloonElement]) {
        showBalloonOverlay(currentBalloonElement);
      }
    });
    
    /* --- Δημιουργία των p5 καμβάδων με draw loop ώστε να ενημερώνονται οι αλλαγές (π.χ. selectedElement) --- */
    function initializeCanvases() {
      Object.keys({ s: 1, p: 1, d: 1, f: 1 }).forEach(function(block) {
        new p5(function(p) {
          let containerLeft, containerTop;
          p.setup = function() {
            let config = { cols: 10, rows: 7 };
            if (block === "s") config = { cols: 2, rows: 7 };
            else if (block === "p") config = { cols: 6, rows: 7 };
            else if (block === "d") config = { cols: 10, rows: 7 };
            else if (block === "f") config = { cols: 14, rows: 7 };
            let canvas = p.createCanvas(config.cols * cellSize, config.rows * cellSize);
            canvas.elt.getContext("2d", { willReadFrequently: true });
            canvas.parent("canvas" + block.toUpperCase());
            containerLeft = 0;
            containerTop = 0;
            p.skipNextClick = true;
            setTimeout(() => { p.skipNextClick = false; }, 100);
            p.mouseClicked = function(event) {
              if (p.skipNextClick) return;
              let globalX = event.clientX;
              let globalY = event.clientY;
              let found = performHitTest(globalX, globalY);
              if(found !== null){
                console.log("Clicked element:", found);
                selectedElement = found;
                showBalloonOverlay(found);
              }
            };
          };
          p.draw = function() {
            p.clear();
            drawElements(p, block, containerLeft, containerTop);
          };
        });
      });
    }
    
    // Δείτε ότι οι υπόλοιπες συναρτήσεις (drawElements, logHitTestCenter, initializeSectorsCanvas, initGroupsCanvases, κλπ) παραμένουν όπως πριν.
    
    // (Οι συναρτήσεις drawElements, initializeSectorsCanvas, initGroupsCanvases κ.ο.κ. διατηρούνται από το προηγούμενο παράδειγμα.)
    
    window.drawElements = drawElements;
    
    loadData().then(() => {
      if (currentMode === "expanded" || currentMode === "collapsed") {
        initializeBackgroundCanvas();
        initializeSectorsCanvas();
        initializePeriodsCanvas();
        initGroupsCanvases();
        initializeCanvases();
      } else if (currentMode === "start") {
        initializeBackgroundCanvas();
        initializeSectorsCanvas();
        initializeCanvases();
      }
      updateCellsPositions();
      console.log("Data loaded and canvases initialized.");
      if (currentMode === "start" && currentCellPositions[3]) {
        showBalloonOverlay(3);
      }
    });
  </script>
</body>
</html>
