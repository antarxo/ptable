<!DOCTYPE html>
<html lang="el">
<head>
  <meta charset="UTF-8">
  <title>Περιοδικός Πίνακας με Balloon</title>
  <link href="https://fonts.googleapis.com/css?family=Roboto&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
  <style>
    /* --- Βασικά Styles --- */
    body { 
      font-family: 'Roboto', sans-serif; 
      margin: 0; 
      overflow: hidden; 
      background: #f7f7f7; 
    }
    .canvas { 
      position: absolute; 
      background: transparent; 
      transition: all 0.5s ease-in-out; 
    }
    canvas {
      padding: 8px;
      filter: drop-shadow(4px 4px 4px rgba(0,0,0,0.5));
      overflow: visible;
    }
    /* --- Background Canvas --- */
    #canvasTableBackground {
      position: absolute; 
      background: white; 
      border: 1px solid rgba(0,0,0,0.1);
      box-shadow: 6px 6px 10px rgba(0,0,0,0.3); 
      z-index: -10;
      opacity: 1;
      transition: all 0.5s ease-in-out;
    }
    /* --- Ομαδοποίηση καμβάδων --- */
    #canvasS_groups, #canvasD_groups, #canvasP_groups { 
      position: absolute;
      z-index: 60;
    }
    /* --- Καμβάδες του πίνακα --- */
    #canvasS { z-index: 10; }
    #canvasF { z-index: 20; }
    #canvasD { z-index: 30; }
    #canvasP { z-index: 40; }
    #canvasPeriods { z-index: 50; }
    /* --- Balloon (Subshells) --- */
    #canvasSubshells {
      position: absolute;
      background: #fff;
      border: 1px solid #333;
      border-radius: 10px;
      box-shadow: 0 3px 3px rgba(0,0,0,0.3);
      padding: 10px;
      z-index: 150;
      display: none;
      transition: all 0.2s ease;
    }
    /* --- Panel με κουμπιά --- */
    #buttonPanel {
      position: fixed; 
      bottom: 20px; 
      right: 20px; 
      z-index: 100;
      display: flex; 
      flex-direction: column;
      gap: 5px;
    }
    #buttonPanel button {
      background-color: #008CBA; 
      color: white; 
      padding: 10px 15px;
      border: none; 
      border-radius: 5px;
      cursor: pointer;
      box-shadow: 4px 4px 4px rgba(0,0,0,0.5);
    }
    /* --- Offscreen canvas για color picking --- */
    #offscreenCanvas { display: none; }
  </style>
</head>
<body>
  <!-- --- Καμβάδες του Περιοδικού Πίνακα --- -->
  <div id="canvasTableBackground"></div>
  <div id="canvasS_groups" class="canvas"></div>
  <div id="canvasD_groups" class="canvas"></div>
  <div id="canvasP_groups" class="canvas"></div>
  <div id="canvasPeriods" class="canvas"></div>
  <div id="canvasS" class="canvas"></div>
  <div id="canvasD" class="canvas"></div>
  <div id="canvasP" class="canvas"></div>
  <div id="canvasF" class="canvas"></div>
  
  <!-- --- Balloon για Subshells --- -->
  <div id="canvasSubshells" class="canvas"></div>
  
  <!-- --- Offscreen Canvas για color picking --- -->
  <canvas id="offscreenCanvas" width="800" height="600"></canvas>
  
  <!-- --- Panel με κουμπιά --- -->
  <div id="buttonPanel">
    <button id="nextState">Επόμενο</button>
    <button id="fillAll">Συμπλήρωσε</button>
    <button id="toggleFBlock" disabled>Σύμπτυξε</button>
    <button id="reset">Reset</button>
  </div>
  
  <script>
    // ===================== Global Variables =====================
    let elements = [];         // Θα φορτωθούν από το elements.json
    let positions = {};        // Θα φορτωθούν από το positions.json
    let isCollapsed = false;
    let currentMode = "start"; // "start", "expanded", "collapsed"
    let currentZ = 3;
    let extraElements = {};
    let postFillingStep = 0;
    let showPeriods = false;
    let cellSize = 40;
    let currentCellPositions = {}; // Για hit-testing
    let subshellsP;           // p5 instance για το balloon

    // Dummy συνάρτηση για getBlockColor – αντικαταστήστε την αν έχετε δική σας υλοποίηση
    window.getBlockColor = function(b) {
      switch(b) {
        case "s": return "#FF477E";
        case "p": return "#26FF31";
        case "d": return "#3F99FF";
        case "f": return "#FFD051";
        default: return "#000";
      }
    };

    // ===================== Λειτουργίες του ptablelike =====================
    function getShift(num, block) {
      if (currentMode !== "start") return 0;
      if (block === "p" && num >= 21 && num <= 30) {
        let effectiveZ = Math.min(currentZ, 30);
        return (effectiveZ - 20) * 42;
      }
      if ((block === "p" || block === "d") && num >= 57 && num <= 70) {
        let effective = Math.min(currentZ, 70);
        return (effective - 56) * 42;
      }
      return 0;
    }
    
    function getShiftContainer(block) {
      if (currentMode !== "start") return 0;
      if (block === "p") {
        if (currentZ <= 20) return 0;
        else if (currentZ <= 30) return (currentZ - 20) * 42;
        else if (currentZ <= 56) return 10 * 42;
        else if (currentZ <= 70) return 10 * 42 + (currentZ - 56) * 42;
        else return 10 * 42 + 14 * 42;
      } else if (block === "d") {
        if (currentZ < 57) return 0;
        else if (currentZ <= 70) return (currentZ - 56) * 42;
        else return 14 * 42;
      }
      return 0;
    }
    
    // Ενημερώνει τις θέσεις των κελιών για το hit-testing
    function updateCellsPositions() {
      currentCellPositions = {};
      for (let e of elements) {
        let num = Number(e.number);
        if (currentMode === "start") {
          if ((num < 3 && !extraElements[num]) || num > currentZ) continue;
        }
        let pos = positions[currentMode] && positions[currentMode][e.number] ? positions[currentMode][e.number] : null;
        if (!pos) continue;
        let offsetX = 0, offsetY = 0;
        if (currentMode === "start" && (e.block === "p" || e.block === "d")) {
          offsetX = getShiftContainer(e.block);
        }
        if (currentMode === "start") {
          if (e.block === "p" && num >= 21 && num <= 30)
            offsetY = getShift(num, e.block);
          else if ((e.block === "p" || e.block === "d") && num >= 57 && num <= 70)
            offsetY = getShift(num, e.block);
        }
        currentCellPositions[e.number] = {
          x: pos.x + offsetX,
          y: pos.y + offsetY,
          width: pos.width,
          height: pos.height
        };
      }
    }
    
    // Υπολογίζει το bounding box των στοιχείων για το background
    function computeModeRegion() {
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      for (let key in currentCellPositions) {
        let pos = currentCellPositions[key];
        minX = Math.min(minX, pos.x);
        minY = Math.min(minY, pos.y);
        maxX = Math.max(maxX, pos.x + pos.width);
        maxY = Math.max(maxY, pos.y + pos.height);
      }
      return (minX === Infinity) ? null : { minX, minY, maxX, maxY };
    }
    
    function initializeBackgroundCanvas() {
      let bg = document.getElementById("canvasTableBackground");
      let margin = 20;
      if (currentMode === "start") {
        let limits = computeModeRegion();
        if (limits) {
          bg.style.left = "17px";
          bg.style.top = (limits.minY - margin) + "px";
          bg.style.width = (limits.maxX + margin - 17) + "px";
          bg.style.height = (limits.maxY - limits.minY + 2 * margin) + "px";
        }
      }
      bg.style.opacity = "1";
    }
    
    // Απλή υλοποίηση για τα canvases κάθε block.
    // Στην πλήρη εφαρμογή οι θέσεις θα φορτώνονται από το positions.json.
    function initializeSectorsCanvas() {
      ["s", "p", "d", "f"].forEach(block => {
        let container = document.getElementById("canvas" + block.toUpperCase());
        container.innerHTML = "";
        // Αν υπάρχει θέση για το block στο positions object, χρησιμοποιείται.
        let pos = (positions[currentMode] && positions[currentMode][block]) || { x: 50 + (block.charCodeAt(0)-115)*100, y: 50, width: 40, height: 40 };
        if (!positions[currentMode]) positions[currentMode] = {};
        positions[currentMode][block] = pos;
        new p5(function(p) {
          p.setup = function() {
            let canvas = p.createCanvas(150, 150);
            canvas.parent("canvas" + block.toUpperCase());
            p.fill("#ccc");
            p.rect(pos.x, pos.y, pos.width, pos.height);
            p.fill(0);
            p.textAlign(p.CENTER, p.CENTER);
            p.text(block.toUpperCase(), pos.x + pos.width/2, pos.y + pos.height/2);
          };
        });
      });
    }
    
    // Εκτέλεση hit-test στο κέντρο της περιοχής
    function logHitTestCenter() {
      let region = computeModeRegion();
      if (region) {
        let centerX = (region.minX + region.maxX) / 2;
        let centerY = (region.minY + region.maxY) / 2;
        console.log("Hit test στο κέντρο: (" + centerX + ", " + centerY + ")");
        performHitTest(centerX, centerY);
      }
    }
    
    // Hit-testing μέσω offscreen canvas και color picking
    function performHitTest(x, y) {
      let region = computeModeRegion();
      if (!region) {
         console.log("Δεν υπάρχουν στοιχεία στο τρέχον mode.");
         return;
      }
      let regionLeft = region.minX, regionTop = region.minY;
      if (x < regionLeft || x > region.maxX || y < regionTop || y > region.maxY) {
         console.log("Κλικ εκτός περιοχής στοιχείων.");
         return;
      }
      let relX = x - regionLeft, relY = y - regionTop;
      let offCanvas = document.getElementById("offscreenCanvas");
      offCanvas.width = region.maxX - region.minX;
      offCanvas.height = region.maxY - region.minY;
      let offCtx = offCanvas.getContext("2d");
      offCtx.clearRect(0, 0, offCanvas.width, offCanvas.height);
      for (let key in currentCellPositions) {
         let pos = currentCellPositions[key];
         let drawX = pos.x - regionLeft;
         let drawY = pos.y - regionTop;
         let num = Number(key);
         let r = (num * 37) % 256;
         let g = (num * 67) % 256;
         let b = (num * 97) % 256;
         offCtx.fillStyle = "rgb(" + r + "," + g + "," + b + ")";
         offCtx.fillRect(drawX, drawY, pos.width, pos.height);
      }
      let pixel = offCtx.getImageData(relX, relY, 1, 1).data;
      if (pixel[3] === 0) {
         console.log("Δεν ανιχνεύτηκε στοιχείο στο (" + x + ", " + y + ")");
      } else {
         let found = null;
         for (let key in currentCellPositions) {
            let pos = currentCellPositions[key];
            let num = Number(key);
            let r = (num * 37) % 256;
            let g = (num * 67) % 256;
            let b = (num * 97) % 256;
            if (pixel[0] === r && pixel[1] === g && pixel[2] === b) {
                found = key;
                break;
            }
         }
         if (found) {
            console.log("Βρέθηκε στοιχείο με Ζ =", found);
            let element = elements.find(e => e.number == found);
            if(element) {
                // Εμφάνιση του balloon με τα subshells (αν υπάρχουν)
                updateBalloonPosition(element);
                if(element.subshells) {
                  drawSubshells({
                    prev: element.subshells,
                    current: element.subshells,
                    next: element.subshells,
                    prevColor: window.getBlockColor(element.block),
                    currentColor: window.getBlockColor(element.block),
                    nextColor: window.getBlockColor(element.block)
                  });
                }
            }
         } else {
            console.log("Δεν βρέθηκε στοιχείο.");
         }
      }
    }
    
    // ===================== Λειτουργίες Balloon (από το ALLtoDOM1) =====================
    window.updateBalloonPosition = function(element) {
      let cs = document.getElementById('canvasSubshells');
      if(!cs) return;
      cs.style.transition = "all 0.2s ease";
      let blockCanvas = document.getElementById("canvas" + element.block.toUpperCase());
      if(!blockCanvas) return;
      let rect = blockCanvas.getBoundingClientRect();
      // Χρησιμοποιούμε τη θέση του blockCanvas μαζί με τις θέσεις από το positions object
      let pos = positions[currentMode] && positions[currentMode][element.block] ? positions[currentMode][element.block] : { x:50, y:50 };
      let defaultLeft = rect.left + pos.x + 40;
      let defaultTop = rect.top + pos.y + 40;
      let leftPos = defaultLeft - 5;
      let topPos = defaultTop;
      let balloonWidth = cs.offsetWidth;
      if(defaultLeft > window.innerWidth / 2) { leftPos = defaultLeft - (33 + balloonWidth); }
      if(leftPos + balloonWidth > window.innerWidth) { leftPos = window.innerWidth - balloonWidth - 5; }
      cs.style.display = "block";
      cs.style.left = leftPos + "px";
      cs.style.top = topPos + "px";
    };
    
    window.drawSubshells = function(data) {
      if (!subshellsP) return;
      let balloonHeight = 40, fontSize = 14, leftMargin = 2, extraMargin = 5;
      subshellsP.clear();
      subshellsP.textSize(fontSize);
      subshellsP.textAlign(subshellsP.LEFT, subshellsP.CENTER);
      let wPrev = subshellsP.textWidth(data.prev || "-");
      let wCurrent = subshellsP.textWidth(data.current || "-");
      let wNext = subshellsP.textWidth(data.next || "-");
      let computedWidth = Math.max(wPrev, wCurrent, wNext) + extraMargin;
      let minWidth = 10, newWidth = Math.max(computedWidth, minWidth);
      subshellsP.resizeCanvas(newWidth, balloonHeight);
      subshellsP.canvas.style.cssText = 'width: ' + newWidth + 'px !important; height: ' + balloonHeight + 'px !important;';
      let rowHeight = balloonHeight / 3;
      subshellsP.textStyle(p5.prototype.NORMAL);
      subshellsP.fill(data.prevColor || "black");
      subshellsP.text(data.prev || "-", leftMargin, rowHeight/2);
      subshellsP.textStyle(p5.prototype.BOLD);
      subshellsP.fill(data.currentColor || "black");
      subshellsP.text(data.current || "-", leftMargin, rowHeight + rowHeight/2);
      subshellsP.textStyle(p5.prototype.NORMAL);
      subshellsP.fill(data.nextColor || "black");
      subshellsP.text(data.next || "-", leftMargin, 2 * rowHeight + rowHeight/2);
    };
    
    function initSubshellsCanvas() {
      if(window.subshellsInitialized) return;
      new p5(function(p) {
        p.setup = function() {
          let canvas = p.createCanvas(10, 40);
          canvas.parent("canvasSubshells");
          subshellsP = p;
          p.noLoop();
        };
      });
      window.subshellsInitialized = true;
    }
    
    // ===================== Event Listeners =====================
    document.getElementById('fillAll').addEventListener('click', function() {
      currentMode = "expanded";
      currentZ = 123;
      initializeBackgroundCanvas();
      initializeSectorsCanvas();
      initSubshellsCanvas();
      updateCellsPositions();
      logHitTestCenter();
    });
    
    document.getElementById('nextState').addEventListener('click', function() {
      if (currentMode !== "start") {
        currentMode = "start";
        currentZ = 3;
        postFillingStep = 0;
        extraElements = {};
        showPeriods = false;
      } else {
        if (currentZ < 122) {
          currentZ++;
        } else {
          postFillingStep++;
          if (postFillingStep === 1) extraElements["1"] = true;
          else if (postFillingStep === 2) extraElements["2"] = true;
          else if (postFillingStep === 3) showPeriods = true;
          else if (postFillingStep === 4) {
            currentMode = "expanded";
            currentZ = 123;
            console.log("Full expanded mode reached.");
          }
        }
      }
      initializeBackgroundCanvas();
      initializeSectorsCanvas();
      updateCellsPositions();
      logHitTestCenter();
    });
    
    document.getElementById('toggleFBlock').addEventListener('click', function() {
      isCollapsed = !isCollapsed;
      this.textContent = isCollapsed ? "Ανάπτυξε" : "Σύμπτυξε";
      currentMode = isCollapsed ? "collapsed" : "expanded";
      initializeBackgroundCanvas();
      updateCellsPositions();
      logHitTestCenter();
    });
    
    document.getElementById('reset').addEventListener('click', function() {
      location.reload();
    });
    
    // ===================== Φόρτωση Δεδομένων από JSON =====================
    async function loadData() {
      try {
        let elementsRes = await fetch('elements.json');
        let positionsRes = await fetch('positions.json');
        elements = await elementsRes.json();
        positions = await positionsRes.json();
        console.log("JSON δεδομένα φορτώθηκαν επιτυχώς.");
        // Μετά τη φόρτωση, εκτελούμε τις αρχικές ρυθμίσεις
        initializeBackgroundCanvas();
        initializeSectorsCanvas();
        initSubshellsCanvas();
        updateCellsPositions();
        logHitTestCenter();
      } catch (e) {
        console.error("Σφάλμα φόρτωσης JSON:", e);
      }
    }
    
    loadData();
    
  </script>
</body>
</html>
