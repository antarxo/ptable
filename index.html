<!DOCTYPE html>
<html lang="el">
<head>
  <meta charset="UTF-8">
  <title>Πίνακας με 4 Καμβάδες - Λογική Συμπλήρωσης</title>
  <!-- Χρήση της γραμματοσειράς Roboto -->
  <link href="https://fonts.googleapis.com/css?family=Roboto&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: 'Roboto', Arial, sans-serif;
      margin: 0;
      overflow: hidden;
      background: #f7f7f7;
    }
    /* Πάνελ πληροφοριών και κουμπιά ελέγχου */
    #infoPanel {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      padding: 10px;
      background: rgba(255,255,255,0.95);
      border: 1px solid #333;
      z-index: 50;
    }
    #controls {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 50;
    }
    #controls button {
      margin: 0 5px;
      padding: 5px 10px;
    }
    /* Διατάξεις για τους 4 καμβάδες */
    /* Full mode: τοποθέτηση οριζόντια στη σειρά */
    .full #canvasS { top: 100px; left: 50px; width: 124px; height: 336px; z-index: 2; }
    .full #canvasF { top: 100px; left: 174px; width: 586px; height: 336px; z-index: 2; }
    .full #canvasD { top: 100px; left: 760px; width: 418px; height: 336px; z-index: 2; }
    .full #canvasP { top: 100px; left: 1178px; width: 250px; height: 336px; z-index: 2; }
    
    /* Collapsed mode: S, D, P παραμένουν στη σειρά, F μετακινείται 100px προς τα κάτω */
    .collapsed #canvasS { top: 100px; left: 50px; width: 124px; height: 336px; z-index: 2; }
    .collapsed #canvasD { top: 100px; left: 174px; width: 418px; height: 336px; z-index: 2; }
    .collapsed #canvasP { top: 100px; left: 592px; width: 250px; height: 336px; z-index: 2; }
    .collapsed #canvasF { top: 200px; left: 174px; width: 586px; height: 336px; z-index: 1; }
    
    /* Βασικές ρυθμίσεις για όλους τους καμβάδες */
    #canvasS, #canvasF, #canvasD, #canvasP {
      position: absolute;
      border: 1px solid #ccc;
      background: #fff;
    }
  </style>
  <!-- Φόρτωση p5.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
</head>
<body class="full">
  <div id="infoPanel">Πληροφορίες στοιχείου...</div>
  <div id="controls">
    <button id="nextElement">Επόμενο</button>
    <button id="fillAll">Συμπλήρωσε</button>
    <button id="toggleMode">Εναλλαγή Mode</button>
    <button id="reset">Reset</button>
  </div>
  <!-- Containers για τους 4 καμβάδες -->
  <div id="canvasS"></div>
  <div id="canvasF"></div>
  <div id="canvasD"></div>
  <div id="canvasP"></div>
  
  <script>
    /* 
      Ενσωματώνοντας τη λογική του last.html (λογική συμπλήρωσης) σε 4 καμβάδες.
      Ο πίνακας κατασκευάζεται δυναμικά και τα δεδομένα αποθηκεύονται στο rowsData.
      Κάθε κελί έχει ιδιότητες όπως number, category, width, height.
      Οι συναρτήσεις addElementToCurrentRow, initialize, createCell, κλπ., είναι όπως στο αρχικό σας αρχείο.
    */
    
    (function() {
      // Global μεταβλητές
      let elementsData = [];
      let rowsData = [];
      let globalElementNumber = 3;
      let currentRowIndex = 3;
      let phase = 1;
      let hideFBlock = false; // Στο παρόν δεν θα χρησιμοποιήσουμε το hideFBlock (αλλά το mode θα ελέγχει την διάταξη)
      const colGap = 42;
      const fillingPatterns = [
        [{ count: 8, shifting: true }],
        [{ count: 8, shifting: false }],
        [{ count: 2, shifting: false }, { count: 10, shifting: true }, { count: 6, shifting: false }],
        [{ count: 2, shifting: false }, { count: 10, shifting: false }, { count: 6, shifting: false }],
        [{ count: 2, shifting: false }, { count: 14, shifting: true }, { count: 10, shifting: false }, { count: 6, shifting: false }],
        [{ count: 2, shifting: false }, { count: 14, shifting: false }, { count: 10, shifting: false }, { count: 6, shifting: false }]
      ];
      
      // Φόρτωση δεδομένων από elements.json (αν υπάρχει)
      function preload() {
        elementsData = loadJSON('elements.json', dataLoaded, dataError);
      }
      function dataLoaded(data) {
        elementsData = data;
        console.log("elements.json loaded successfully.");
      }
      function dataError(err) {
        console.error("Error loading elements.json", err);
        elementsData = null;
      }
      
      // Utility: getCategory (όπως στο αρχικό)
      function getCategory(n) {
        const alkaliMetals = [3, 11, 19, 37, 55, 87];
        if (n === 1) return 'hydrogen-color';
        if (alkaliMetals.includes(n)) return 'alkali-block';
        if (n === 1 || n === 2 || [4,12,20,38,56,88].includes(n)) return 's-block';
        if ((n >= 57 && n <= 70) || (n >= 89 && n <= 102)) return 'f-block';
        if ((n >= 5 && n <= 10) || (n >= 13 && n <= 18) || (n >= 81 && n <= 86)) return 'p-block';
        if ((n >= 21 && n <= 30) || (n >= 39 && n <= 48) || (n >= 71 && n <= 80) || (n >= 103 && n <= 112)) return 'd-block';
        return 'p-block';
      }
      
      const CATEGORY_COLORS = {
        'alkali-block': '#ff9999',
        's-block': '#ffcccc',
        'p-block': '#ccffcc',
        'd-block': '#ccccff',
        'f-block': '#ffe5cc',
        'group-name': '#f0f0f0',
        'period-label': '#f0f0f0',
        'hydrogen-color': '#ffff99'
      };
      
      // Αρχικοποίηση του πίνακα
      function initialize() {
        rowsData = [];
        for (let i = 0; i < 9; i++) {
          let cells = (i < 2) ? new Array(32).fill(null) : [];
          rowsData.push({
            cells: cells,
            shiftedColumns: 0,
            currentSegment: 0,
            countInSegment: 0,
            insertionIndex: 0,
            periodLabel: null
          });
        }
        globalElementNumber = 3;
        currentRowIndex = 3;
        phase = 1;
      }
      
      function createCell(elObj) {
        let cell = {
          number: elObj.number,
          category: elObj.category,
          width: 40,
          height: (elObj.category === 'group-name' ? 20 : 40),
          fixed: !!elObj.fixed
        };
        if (elementsData && elementsData.length >= elObj.number) {
          cell.details = elementsData[elObj.number - 1];
        }
        return cell;
      }
      
      function shiftBlockRight(rowIndex, groupRows) {
        groupRows.forEach(i => {
          let row = rowsData[i];
          let insertPos = rowsData[rowIndex].insertionIndex + row.shiftedColumns;
          row.cells.splice(insertPos, 0, null);
          row.shiftedColumns++;
        });
      }
      
      function handleShiftingForRow(currentRowIndex) {
        let groupRows = [];
        if (currentRowIndex === 3) groupRows = [0, 1, 2];
        else if (currentRowIndex === 5) groupRows = [0, 1, 2, 3, 4];
        else if (currentRowIndex === 7) groupRows = [0, 1, 2, 3, 4, 5, 6];
        shiftBlockRight(currentRowIndex, groupRows);
      }
      
      function addElementToCurrentRow() {
        if (phase === 1) {
          if (globalElementNumber > 118) {
            currentRowIndex = 2;
            globalElementNumber = 1;
            phase = 2;
            redrawAll();
            return;
          }
          const row = rowsData[currentRowIndex];
          if (currentRowIndex >= 3 && currentRowIndex <= 8 && globalElementNumber <= 118) {
            let pattern = fillingPatterns[currentRowIndex - 3][row.currentSegment];
            let cell = createCell({
              number: globalElementNumber,
              category: getCategory(globalElementNumber)
            });
            if (pattern.shifting) {
              handleShiftingForRow(currentRowIndex);
            }
            let targetIndex = row.insertionIndex;
            while (row.cells[targetIndex] != null) {
              targetIndex++;
              if (targetIndex >= row.cells.length) row.cells.push(null);
            }
            row.cells[targetIndex] = cell;
            globalElementNumber++;
            row.countInSegment++;
            if (row.countInSegment === pattern.count) {
              row.currentSegment++;
              row.countInSegment = 0;
              row.insertionIndex = row.cells.length;
            }
            if (row.currentSegment >= fillingPatterns[currentRowIndex - 3].length) {
              currentRowIndex++;
            }
            updateInfoPanel(cell);
          }
          redrawAll();
        } else if (phase === 2) {
          const row = rowsData[currentRowIndex];
          let insertIndex = (globalElementNumber === 1) ? 0 : 31;
          while (row.cells.length <= insertIndex) row.cells.push(null);
          let cell = createCell({
            number: globalElementNumber,
            category: getCategory(globalElementNumber)
          });
          row.cells[insertIndex] = cell;
          globalElementNumber++;
          if (globalElementNumber > 2) phase = 3;
          updateInfoPanel(cell);
          redrawAll();
        } else if (phase === 3) {
          addPeriodNames();
          phase = 4;
          redrawAll();
        } else if (phase === 4) {
          addOldGroupNumbers();
          phase = 5;
          redrawAll();
        } else if (phase === 5) {
          addNewGroupNumbers();
          phase = 6;
          redrawAll();
        }
      }
      
      function addPeriodNames() {
        rowsData[2].periodLabel = "1η Κ";
        rowsData[3].periodLabel = "2η L";
        rowsData[4].periodLabel = "3η M";
        rowsData[5].periodLabel = "4η N";
        rowsData[6].periodLabel = "5η O";
        rowsData[7].periodLabel = "6η P";
        rowsData[8].periodLabel = "7η Q";
      }
      
      function addNewGroupNumbers() {
        let row = rowsData[0];
        row.cells = new Array(32).fill(null);
        row.cells[0] = createCell({ number: 1, category: 'group-name' });
        row.cells[1] = createCell({ number: 2, category: 'group-name' });
        let num = 3;
        for (let i = 16; i < 32; i++) {
          row.cells[i] = createCell({ number: num, category: 'group-name' });
          num++;
        }
      }
      
      function addOldGroupNumbers() {
        let oldNumbers = [
          "IA", "IIA", "IIIB", "IVB", "VB", "VIB", "VIIB", "VIIIB",
          "VIIIB", "VIIIB", "IB", "IIB", "IIIA", "IVA", "VA", "VIA", "VIIA", "VIIIA"
        ];
        let row = rowsData[1];
        row.cells = new Array(32).fill(null);
        row.cells[0] = createCell({ number: oldNumbers[0], category: 'group-name' });
        row.cells[1] = createCell({ number: oldNumbers[1], category: 'group-name' });
        let idx = 2;
        for (let i = 16; i < 32; i++) {
          row.cells[i] = createCell({ number: oldNumbers[idx], category: 'group-name' });
          idx++;
        }
      }
      
      function getTableBottom() {
        let y = 80;
        let gap = 2;
        for (let row = 0; row < 9; row++) {
          let cellH = (row < 2) ? 20 : 40;
          y += cellH + gap;
        }
        return y;
      }
      
      function updateInfoPanelDimensions() {
        const infoPanel = document.getElementById("infoPanel");
        // Απλή ρύθμιση για demo
        infoPanel.style.width = "300px";
      }
      
      function updateInfoPanel(cell) {
        const infoPanel = document.getElementById('infoPanel');
        if (elementsData && cell && cell.details) {
          infoPanel.innerHTML = `<strong>${cell.details.name} (${cell.details.symbol})</strong> [Z=${cell.details.number}]`;
        } else if (cell) {
          infoPanel.innerHTML = `<strong>${cell.number}</strong> [${cell.category}]`;
        } else {
          infoPanel.innerHTML = "Πληροφορίες στοιχείου...";
        }
      }
      
      function clearInfoPanel() {
        document.getElementById('infoPanel').innerHTML = "Πληροφορίες στοιχείου...";
      }
      
      function handleMouseClick(x, y) {
        let found = false;
        for (let i = 0; i < rowsData.length; i++) {
          let row = rowsData[i];
          for (let j = 0; j < row.cells.length; j++) {
            let cell = row.cells[j];
            if (cell && x >= cell.drawX && x <= cell.drawX + cell.drawW &&
                y >= cell.drawY && y <= cell.drawY + cell.drawH) {
              updateInfoPanel(cell);
              found = true;
              break;
            }
          }
          if (found) break;
        }
        if (!found) clearInfoPanel();
      }
      
      function redrawAll() {
        sP5.redraw();
        dP5.redraw();
        pP5.redraw();
        fP5.redraw();
      }
      
      /* --- Σχεδίαση ανά τομέα από rowsData --- */
      // Για κάθε p5 sketch, σχεδιάζουμε μόνο τα κελιά που αντιστοιχούν σε ένα συγκεκριμένο block.
      // Ορίζουμε τις ομάδες:
      // S: cell.category ∈ {"hydrogen-color", "alkali-block", "s-block"}
      // D: cell.category === "d-block"
      // P: cell.category === "p-block"
      // F: cell.category === "f-block"
      
      function drawBlock(p, blockCategories) {
        let gap = 2;
        let yOffset = 80;
        for (let row = 0; row < rowsData.length; row++) {
          let cellH = (row < 2) ? 20 : 40;
          let xOffset = 0;
          for (let j = 0; j < rowsData[row].cells.length; j++) {
            let cell = rowsData[row].cells[j];
            if (cell && blockCategories.includes(cell.category)) {
              p.fill(CATEGORY_COLORS[cell.category] || "#ddd");
              p.stroke(150);
              p.rect(xOffset, yOffset, cell.width, cellH);
              p.fill(0);
              p.textSize(12);
              p.textAlign(p.CENTER, p.CENTER);
              p.text(cell.number, xOffset + cell.width/2, yOffset + cellH/2);
              // Αποθήκευση συντεταγμένων για interactivity
              cell.drawX = xOffset;
              cell.drawY = yOffset;
              cell.drawW = cell.width;
              cell.drawH = cellH;
              xOffset += cell.width + gap;
            }
          }
          yOffset += cellH + gap;
        }
      }
      
      // p5 sketches για κάθε τομέα:
      
      // Sketch για τον S τομέα (S, hydrogen, alkali)
      let sketchS = function(p) {
        p.setup = function() {
          p.createCanvas(124, 336);
          p.noLoop();
        };
        p.draw = function() {
          drawBlock(p, ["hydrogen-color", "alkali-block", "s-block"]);
        };
      };
      
      // Sketch για τον D τομέα
      let sketchD = function(p) {
        p.setup = function() {
          p.createCanvas(418, 336);
          p.noLoop();
        };
        p.draw = function() {
          drawBlock(p, ["d-block"]);
        };
      };
      
      // Sketch για τον P τομέα
      let sketchP = function(p) {
        p.setup = function() {
          p.createCanvas(250, 336);
          p.noLoop();
        };
        p.draw = function() {
          drawBlock(p, ["p-block"]);
        };
      };
      
      // Sketch για τον F τομέα
      let sketchF = function(p) {
        p.setup = function() {
          p.createCanvas(586, 336);
          p.noLoop();
        };
        p.draw = function() {
          drawBlock(p, ["f-block"]);
        };
      };
      
      // Δημιουργία των 4 p5 instances στους αντίστοιχους καμβάδες
      let sP5 = new p5(sketchS, 'canvasS');
      let dP5 = new p5(sketchD, 'canvasD');
      let pP5 = new p5(sketchP, 'canvasP');
      let fP5 = new p5(sketchF, 'canvasF');
      
      /* --- Event Listeners για τα κουμπιά --- */
      document.getElementById('nextElement').addEventListener('click', function() {
        addElementToCurrentRow();
        redrawAll();
      });
      document.getElementById('fillAll').addEventListener('click', function() {
        while (phase < 6 || (phase === 1 && globalElementNumber <= 118)) {
          addElementToCurrentRow();
        }
        redrawAll();
      });
      document.getElementById('reset').addEventListener('click', function() {
        window.location.reload();
      });
      document.getElementById('toggleMode').addEventListener('click', function() {
        // Εναλλαγή μεταξύ full και collapsed mode.
        // Στο full mode, οι 4 καμβάδες τοποθετούνται οριζόντια.
        // Στο collapsed mode, οι καμβάδες S, D και P παραμένουν στην πρώτη σειρά,
        // ενώ ο F καμβάς μετακινείται 100px προς τα κάτω.
        mode = (mode === "full") ? "collapsed" : "full";
        document.body.className = mode;
        // Ενημέρωση θέσεων μέσω CSS
        if (mode === "collapsed") {
          document.getElementById('canvasF').style.top = "200px";
          document.getElementById('canvasF').style.zIndex = "1";
          document.getElementById('canvasS').style.zIndex = "2";
          document.getElementById('canvasD').style.zIndex = "2";
          document.getElementById('canvasP').style.zIndex = "2";
        } else {
          document.getElementById('canvasF').style.top = "";
          document.getElementById('canvasF').style.zIndex = "";
        }
        // Ανανεώνουμε όλους τους καμβάδες
        sP5.redraw();
        dP5.redraw();
        pP5.redraw();
        fP5.redraw();
      });
      
      window.addEventListener('resize', function() {
        sP5.redraw();
        dP5.redraw();
        pP5.redraw();
        fP5.redraw();
      });
      
      // Αρχική εκτέλεση
      initialize();
      updateInfoPanelDimensions();
    })();
  </script>
</body>
</html>
