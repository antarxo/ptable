<!DOCTYPE html>
<html lang="el">
<head>
  <meta charset="UTF-8">
  <title>Περιοδικός Πίνακας - ptablelike με Balloon</title>
  <link href="https://fonts.googleapis.com/css?family=Roboto&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
  <style>
    /* ----- Αρχικά styles όπως στο ptablelike ----- */
    body { 
      font-family: 'Roboto', sans-serif; 
      margin: 0; 
      overflow: hidden; 
      background: #f7f7f7; 
    }
    .canvas { 
      position: absolute; 
      background: transparent; 
      transition: all 0.5s ease-in-out; 
    }
    canvas {
      padding: 8px;
      filter: drop-shadow(4px 4px 4px rgba(0,0,0,0.5));
      overflow: visible;
    }
    #canvasTableBackground {
      position: absolute; 
      background: white; 
      border: 1px solid rgba(0,0,0,0.1);
      box-shadow: 6px 6px 10px rgba(0,0,0,0.3); 
      z-index: -10;
      opacity: 1;
      transition: all 0.5s ease-in-out;
    }
    /* ----- Τα υπόλοιπα styles των canvases (S, D, P, F, Groups, Periods) όπως στο αρχικό ptablelike ----- */
    /* ... (παραλείπονται εδώ γιατί δεν γίνονται τροποποιήσεις) ... */
    
    /* ----- Styles για το Balloon (από ALLtoDOM1) ----- */
    #canvasSubshells {
      position: absolute;
      background: #fff;
      border: 1px solid #333;
      border-radius: 10px;
      box-shadow: 0 3px 3px rgba(0,0,0,0.3);
      padding: 10px;
      z-index: 150;
      display: none;
      transition: all 0.2s ease;
    }
    
    /* ----- Panel κουμπιών ----- */
    #buttonPanel {
      position: fixed; 
      bottom: 20px; 
      right: 20px; 
      z-index: 100;
      display: flex; 
      flex-direction: column;
      gap: 5px;
    }
    #buttonPanel button {
      background-color: #008CBA; 
      color: white; 
      padding: 10px 15px;
      border: none; 
      border-radius: 5px;
      cursor: pointer;
      box-shadow: 4px 4px 4px rgba(0,0,0,0.5);
    }
    /* ----- Offscreen canvas για color picking ----- */
    #offscreenCanvas { display: none; }
  </style>
</head>
<body>
  <!-- ----- HTML δομή όπως στο ptablelike ----- -->
  <div id="canvasTableBackground"></div>
  <div id="canvasS_groups" class="canvas"></div>
  <div id="canvasD_groups" class="canvas"></div>
  <div id="canvasP_groups" class="canvas"></div>
  <div id="canvasPeriods" class="canvas"></div>
  <div id="canvasS" class="canvas"></div>
  <div id="canvasD" class="canvas"></div>
  <div id="canvasP" class="canvas"></div>
  <div id="canvasF" class="canvas"></div>
  
  <!-- ----- Το Balloon για Subshells ----- -->
  <div id="canvasSubshells" class="canvas"></div>
  
  <!-- ----- Offscreen Canvas ----- -->
  <canvas id="offscreenCanvas" width="800" height="600"></canvas>
  
  <!-- ----- Panel με κουμπιά ----- -->
  <div id="buttonPanel">
    <button id="nextState">Επόμενο</button>
    <button id="fillAll">Συμπλήρωσε</button>
    <button id="toggleFBlock" disabled>Σύμπτυξε</button>
    <button id="reset">Reset</button>
  </div>
  
  <script>
    /* ===============================================
       Ο κώδικας παρακάτω είναι ακριβώς αυτός του ptablelike
       (με τις βασικές συναρτήσεις, hit‑testing, θέση στοιχείων κ.λπ.)
       και δεν γίνεται τροποποίηση στη λογική του.
       Ενσωματώνουμε μόνο την εμφάνιση του Balloon χωρίς να "βλάψουμε" την αρχική λειτουργία.
       =============================================== */
    
    // ---------- Global Variables ----------
    let elements = [];         // Φόρτωση από το elements.json
    let positions = {};        // Φόρτωση από το positions.json
    let isCollapsed = false;
    let currentMode = "start"; // Modes: start, expanded, collapsed
    let currentZ = 3;
    let extraElements = {};
    let postFillingStep = 0;
    let showPeriods = false;
    let cellSize = 40;
    let currentCellPositions = {}; // Για hit‑testing
    
    // ---------- Για το Balloon (από ALLtoDOM1) ----------
    let subshellsP;
    window.getBlockColor = function(b) {
      switch(b) {
        case "s": return "#FF477E";
        case "p": return "#26FF31";
        case "d": return "#3F99FF";
        case "f": return "#FFD051";
        default: return "#000";
      }
    };
    
    // ---------- Αρχικές συναρτήσεις του ptablelike (όπως στα αρχεία σας) ----------
    function getShift(num, block) {
      if (currentMode !== "start") return 0;
      if (block === "p" && num >= 21 && num <= 30) {
        let effectiveZ = Math.min(currentZ, 30);
        return (effectiveZ - 20) * 42;
      }
      if ((block === "p" || block === "d") && num >= 57 && num <= 70) {
        let effective = Math.min(currentZ, 70);
        return (effective - 56) * 42;
      }
      return 0;
    }
    
    function getShiftContainer(block) {
      if (currentMode !== "start") return 0;
      if (block === "p") {
        if (currentZ <= 20) return 0;
        else if (currentZ <= 30) return (currentZ - 20) * 42;
        else if (currentZ <= 56) return 10 * 42;
        else if (currentZ <= 70) return 10 * 42 + (currentZ - 56) * 42;
        else return 10 * 42 + 14 * 42;
      } else if (block === "d") {
        if (currentZ < 57) return 0;
        else if (currentZ <= 70) return (currentZ - 56) * 42;
        else return 14 * 42;
      }
      return 0;
    }
    
    function updateCellsPositions() {
      currentCellPositions = {};
      elements.forEach(e => {
        let num = Number(e.number);
        if (currentMode === "start") {
          if ((num < 3 && !extraElements[num]) || num > currentZ) return;
        }
        let pos = positions[currentMode] && positions[currentMode][e.number] ? positions[currentMode][e.number] : null;
        if (!pos) return;
        let offsetX = 0, offsetY = 0;
        if (currentMode === "start" && (e.block === "p" || e.block === "d"))
          offsetX = getShiftContainer(e.block);
        if (currentMode === "start") {
          if (e.block === "p" && num >= 21 && num <= 30)
            offsetY = getShift(num, e.block);
          else if ((e.block === "p" || e.block === "d") && num >= 57 && num <= 70)
            offsetY = getShift(num, e.block);
        }
        currentCellPositions[e.number] = {
          x: pos.x + offsetX,
          y: pos.y + offsetY,
          width: pos.width,
          height: pos.height
        };
      });
    }
    
    function computeModeRegion() {
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      for (let key in currentCellPositions) {
        let pos = currentCellPositions[key];
        minX = Math.min(minX, pos.x);
        minY = Math.min(minY, pos.y);
        maxX = Math.max(maxX, pos.x + pos.width);
        maxY = Math.max(maxY, pos.y + pos.height);
      }
      return (minX === Infinity) ? null : { minX, minY, maxX, maxY };
    }
    
    function initializeBackgroundCanvas() {
      let bg = document.getElementById("canvasTableBackground");
      let margin = 20;
      if (currentMode === "start") {
        let limits = computeModeRegion();
        if (limits) {
          bg.style.left = "17px";
          bg.style.top = (limits.minY - margin) + "px";
          bg.style.width = (limits.maxX + margin - 17) + "px";
          bg.style.height = (limits.maxY - limits.minY + 2 * margin) + "px";
        }
      }
      bg.style.opacity = "1";
    }
    
    function initializeSectorsCanvas() {
      // Χρησιμοποιεί τις θέσεις από το positions.json (όπως στο αρχικό σας ptablelike)
      ["s", "p", "d", "f"].forEach(block => {
        let container = document.getElementById("canvas" + block.toUpperCase());
        container.innerHTML = "";
        let pos = positions[currentMode] && positions[currentMode][block] ? positions[currentMode][block] : null;
        if (!pos) return;
        new p5(function(p) {
          p.setup = function() {
            let canvas = p.createCanvas(pos.width * 1.5, pos.height * 1.5);
            canvas.parent("canvas" + block.toUpperCase());
            p.fill("#ccc");
            p.rect(pos.x, pos.y, pos.width, pos.height);
            p.fill(0);
            p.textAlign(p.CENTER, p.CENTER);
            p.text(block.toUpperCase(), pos.x + pos.width/2, pos.y + pos.height/2);
          };
        });
      });
    }
    
    function logHitTestCenter() {
      let region = computeModeRegion();
      if (region) {
        let centerX = (region.minX + region.maxX) / 2;
        let centerY = (region.minY + region.maxY) / 2;
        console.log("Hit test στο κέντρο: (" + centerX + ", " + centerY + ")");
        performHitTest(centerX, centerY);
      }
    }
    
    function performHitTest(x, y) {
      let region = computeModeRegion();
      if (!region) {
         console.log("Δεν υπάρχουν στοιχεία στο τρέχον mode.");
         return;
      }
      let regionLeft = region.minX, regionTop = region.minY;
      if (x < regionLeft || x > region.maxX || y < regionTop || y > region.maxY) {
         console.log("Κλικ εκτός περιοχής στοιχείων.");
         return;
      }
      let relX = x - regionLeft, relY = y - regionTop;
      let offCanvas = document.getElementById("offscreenCanvas");
      offCanvas.width = region.maxX - region.minX;
      offCanvas.height = region.maxY - region.minY;
      let offCtx = offCanvas.getContext("2d");
      offCtx.clearRect(0, 0, offCanvas.width, offCanvas.height);
      for (let key in currentCellPositions) {
         let pos = currentCellPositions[key];
         let drawX = pos.x - regionLeft;
         let drawY = pos.y - regionTop;
         let num = Number(key);
         let r = (num * 37) % 256;
         let g = (num * 67) % 256;
         let b = (num * 97) % 256;
         offCtx.fillStyle = "rgb(" + r + "," + g + "," + b + ")";
         offCtx.fillRect(drawX, drawY, pos.width, pos.height);
      }
      let pixel = offCtx.getImageData(relX, relY, 1, 1).data;
      if (pixel[3] === 0) {
         console.log("Δεν ανιχνεύτηκε στοιχείο στο (" + x + ", " + y + ")");
      } else {
         let found = null;
         for (let key in currentCellPositions) {
            let pos = currentCellPositions[key];
            let num = Number(key);
            let r = (num * 37) % 256;
            let g = (num * 67) % 256;
            let b = (num * 97) % 256;
            if (pixel[0] === r && pixel[1] === g && pixel[2] === b) {
                found = key;
                break;
            }
         }
         if (found) {
            console.log("Βρέθηκε στοιχείο με Ζ =", found);
            let element = elements.find(e => e.number == found);
            if(element) {
                // Εδώ καλείται η λειτουργία του Balloon χωρίς να αλλάζει η βασική λογική
                updateBalloonPosition(element);
                if(element.subshells) {
                  drawSubshells({
                    prev: element.subshells,
                    current: element.subshells,
                    next: element.subshells,
                    prevColor: window.getBlockColor(element.block),
                    currentColor: window.getBlockColor(element.block),
                    nextColor: window.getBlockColor(element.block)
                  });
                }
            }
         } else {
            console.log("Δεν βρέθηκε στοιχείο.");
         }
      }
    }
    
    // ---------- Λειτουργίες για το Balloon (χωρίς αλλαγές στη λογική) ----------
    window.updateBalloonPosition = function(element) {
  let cs = document.getElementById('canvasSubshells');
  if (!cs) return;
  cs.style.transition = "all 0.2s ease";
  // Λαμβάνουμε απευθείας την απόλυτη θέση για το στοιχείο, βάσει του element.number
  let pos = positions[currentMode] && positions[currentMode][element.number];
  if (!pos) return;
  // Προσθέτουμε ένα σταθερό offset για το balloon, π.χ. 40 pixels
  let defaultLeft = pos.x + 40;
  let defaultTop = pos.y + 40;
  cs.style.display = "block";
  cs.style.left = defaultLeft + "px";
  cs.style.top = defaultTop + "px";
};

    
    window.drawSubshells = function(data) {
      if (!subshellsP) return;
      let balloonHeight = 40, fontSize = 14, leftMargin = 2, extraMargin = 5;
      subshellsP.clear();
      subshellsP.textSize(fontSize);
      subshellsP.textAlign(subshellsP.LEFT, subshellsP.CENTER);
      let wPrev = subshellsP.textWidth(data.prev || "-");
      let wCurrent = subshellsP.textWidth(data.current || "-");
      let wNext = subshellsP.textWidth(data.next || "-");
      let computedWidth = Math.max(wPrev, wCurrent, wNext) + extraMargin;
      let minWidth = 10, newWidth = Math.max(computedWidth, minWidth);
      subshellsP.resizeCanvas(newWidth, balloonHeight);
      subshellsP.canvas.style.cssText = 'width: ' + newWidth + 'px !important; height: ' + balloonHeight + 'px !important;';
      let rowHeight = balloonHeight / 3;
      subshellsP.textStyle(p5.prototype.NORMAL);
      subshellsP.fill(data.prevColor || "black");
      subshellsP.text(data.prev || "-", leftMargin, rowHeight/2);
      subshellsP.textStyle(p5.prototype.BOLD);
      subshellsP.fill(data.currentColor || "black");
      subshellsP.text(data.current || "-", leftMargin, rowHeight + rowHeight/2);
      subshellsP.textStyle(p5.prototype.NORMAL);
      subshellsP.fill(data.nextColor || "black");
      subshellsP.text(data.next || "-", leftMargin, 2 * rowHeight + rowHeight/2);
    };
    
    function initSubshellsCanvas() {
      if(window.subshellsInitialized) return;
      new p5(function(p) {
        p.setup = function() {
          let canvas = p.createCanvas(10, 40);
          canvas.parent("canvasSubshells");
          subshellsP = p;
          p.noLoop();
        };
      });
      window.subshellsInitialized = true;
    }
    
    // ---------- Event Listeners (χωρίς αλλαγές στη βασική λειτουργία) ----------
    document.getElementById('fillAll').addEventListener('click', function() {
      currentMode = "expanded";
      currentZ = 123;
      initializeBackgroundCanvas();
      initializeSectorsCanvas();
      initSubshellsCanvas();
      updateCellsPositions();
      logHitTestCenter();
    });
    
    document.getElementById('nextState').addEventListener('click', function() {
      if (currentMode !== "start") {
        currentMode = "start";
        currentZ = 3;
        postFillingStep = 0;
        extraElements = {};
        showPeriods = false;
      } else {
        if (currentZ < 122) {
          currentZ++;
        } else {
          postFillingStep++;
          if (postFillingStep === 1) extraElements["1"] = true;
          else if (postFillingStep === 2) extraElements["2"] = true;
          else if (postFillingStep === 3) showPeriods = true;
          else if (postFillingStep === 4) {
            currentMode = "expanded";
            currentZ = 123;
            console.log("Full expanded mode reached.");
          }
        }
      }
      initializeBackgroundCanvas();
      initializeSectorsCanvas();
      updateCellsPositions();
      logHitTestCenter();
    });
    
    document.getElementById('toggleFBlock').addEventListener('click', function() {
      isCollapsed = !isCollapsed;
      this.textContent = isCollapsed ? "Ανάπτυξε" : "Σύμπτυξε";
      currentMode = isCollapsed ? "collapsed" : "expanded";
      initializeBackgroundCanvas();
      updateCellsPositions();
      logHitTestCenter();
    });
    
    document.getElementById('reset').addEventListener('click', function() {
      location.reload();
    });
    
    // ---------- Φόρτωση δεδομένων από JSON ----------
    async function loadData() {
      try {
        let elementsRes = await fetch('elements.json');
        let positionsRes = await fetch('positions.json');
        elements = await elementsRes.json();
        positions = await positionsRes.json();
        console.log("JSON δεδομένα φορτώθηκαν επιτυχώς.");
        // Εκτέλεση αρχικών ρυθμίσεων
        initializeBackgroundCanvas();
        initializeSectorsCanvas();
        initSubshellsCanvas();
        updateCellsPositions();
        logHitTestCenter();
      } catch (e) {
        console.error("Σφάλμα φόρτωσης JSON:", e);
      }
    }
    
    loadData();
    
  </script>
</body>
</html>
