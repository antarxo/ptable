<!DOCTYPE html>
<html lang="el">
<head>
  <meta charset="UTF-8">
  <title>Περιοδικός Πίνακας με Complex Balloon Overlay</title>
  <link href="https://fonts.googleapis.com/css?family=Roboto&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
  <style>
    body { 
      font-family: 'Roboto', sans-serif;
      margin: 0;
      overflow: hidden;
      background: #f7f7f7;
    }
    .canvas {
      position: absolute;
      background: transparent;
      transition: all 0.5s ease-in-out;
    }
    canvas {
      padding: 8px;
      filter: drop-shadow(4px 4px 4px rgba(0,0,0,0.5));
      overflow: visible;
    }
    /* Background canvas */
    #canvasTableBackground {
      position: absolute;
      background: white;
      border: 1px solid rgba(0,0,0,0.1);
      box-shadow: 6px 6px 10px rgba(0,0,0,0.3);
      z-index: -10;
      opacity: 1;
      transition: all 0.5s ease-in-out;
    }
    /* Group canvases */
    #canvasS_groups, #canvasD_groups, #canvasP_groups {
      position: absolute;
      z-index: 60;
    }
    /* Sector canvases */
    #canvasS { z-index: 10; }
    #canvasF { z-index: 20; }
    #canvasD { z-index: 30; }
    #canvasP { z-index: 40; }
    #canvasPeriods { z-index: 50; }
    /* Button panel */
    #buttonPanel {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 100;
      display: flex;
      flex-direction: column;
      gap: 5px;
    }
    #buttonPanel button {
      background-color: #008CBA;
      color: white;
      padding: 10px 15px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      box-shadow: 4px 4px 4px rgba(0,0,0,0.5);
    }
    /* Offscreen canvas */
    #offscreenCanvas { display: none; }
    /* Balloon overlay */
    #balloonOverlay {
      position: absolute;
      background: white;
      border: 1px solid rgba(0,0,0,0.2);
      box-shadow: 2px 2px 6px rgba(0,0,0,0.3);
      padding: 6px 8px;
      border-radius: 5px;
      z-index: 150;
      visibility: hidden;
      opacity: 0;
      transition: opacity 0.3s ease;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <!-- Καμβάδες -->
  <div id="canvasTableBackground"></div>
  <div id="canvasS_groups" class="canvas"></div>
  <div id="canvasD_groups" class="canvas"></div>
  <div id="canvasP_groups" class="canvas"></div>
  
  <div id="canvasPeriods" class="canvas"></div>
  <div id="canvasS" class="canvas"></div>
  <div id="canvasD" class="canvas"></div>
  <div id="canvasP" class="canvas"></div>
  <div id="canvasF" class="canvas"></div>

  <!-- Κουμπιά -->
  <div id="buttonPanel">
    <button id="nextState">Επόμενο</button>
    <button id="fillAll">Συμπλήρωσε</button>
    <button id="toggleFBlock" disabled>Σύμπτυξε</button>
    <button id="reset">Reset</button>
  </div>
  
  <!-- Offscreen canvas -->
  <canvas id="offscreenCanvas" width="800" height="600"></canvas>
  
  <!-- Balloon overlay -->
  <div id="balloonOverlay"></div>
  
  <script>
    /* --- Global Variables --- */
    let elements = [];
    let positions = {};
    let isCollapsed = false;
    let currentMode = "start";
    let currentZ = 3;
    let extraElements = {};
    let showPeriods = false;
    let cellSize = 40;
    let currentCellPositions = {};
    let currentBalloonElement = null;
    let selectedElement = null; // Το κλικαρισμένο κελί

    /* --- Global Helper Functions --- */
    function getSubshells(element) {
      if (!element) return [];
      if (typeof element.subshells === "string") return element.subshells.split(" ");
      if (Array.isArray(element.subshells)) return element.subshells;
      return [];
    }
    
    function shellLetter(n) {
      let mapping = { "1": "K", "2": "L", "3": "M", "4": "N", "5": "O", "6": "P" };
      return mapping[n] || n;
    }
    
    function formatSubshell(subshell) {
      let match = subshell.match(/^(\d+)[a-zA-Z]+(\d+)/);
      if(match){
         let principal = match[1];
         let count = match[2];
         return shellLetter(principal) + "(" + count + ")";
      }
      return subshell;
    }
    
    function getFormattedLine(element, isCurrent) {
      let subs = getSubshells(element);
      let formattedArr = subs.map(subshell => formatSubshell(subshell));
      if(formattedArr.length > 0) {
         formattedArr[formattedArr.length - 1] = "<b>" + formattedArr[formattedArr.length - 1] + "</b>";
      }
      return formattedArr.join(" ");
    }
    
    /* --- Helper Functions for Finding Elements --- */
    function getPrevElement(currentElement) {
      let prev = elements.find(e => e.col == currentElement.col && e.block == currentElement.block && e.row == currentElement.row - 1);
      if(prev) return prev;
      let candidates = elements.filter(e => e.col == currentElement.col && e.block == currentElement.block && e.row < currentElement.row);
      if(candidates.length > 0) {
         candidates.sort((a, b) => b.row - a.row);
         return candidates[0];
      }
      return null;
    }
    
    function getNextElement(currentElement) {
      let next = elements.find(e => e.col == currentElement.col && e.block == currentElement.block && e.row == currentElement.row + 1);
      if(next) return next;
      let candidates = elements.filter(e => e.col == currentElement.col && e.block == currentElement.block && e.row > currentElement.row);
      if(candidates.length > 0) {
         candidates.sort((a, b) => a.row - b.row);
         return candidates[0];
      }
      return null;
    }
    
    /* --- Functions for Drawing --- */
    // Draw elements in each p5 canvas with a draw loop for dynamic updates
    function drawElements(p, block, containerLeft, containerTop) {
      let colors = { s: "#FF477E", p: "#26FF31", d: "#3F99FF", f: "#FFD051" };
      p.clear();
      elements.filter(e => e.block === block).forEach(e => {
        let num = Number(e.number);
        if (currentMode === "start") {
          if ((num < 3 && !extraElements[num]) || num > currentZ) return;
        }
        let pos = positions[currentMode][e.number] ||
                  ((e.number === "1" || e.number === "2") ? positions["start"][e.number] : null);
        if (pos) {
          let relativeX = pos.x - containerLeft;
          let relativeY = pos.y - containerTop;
          if (currentMode === "start") {
            if (block === "p" && num >= 21 && num <= 30)
              relativeY += getShift(num, block);
            else if ((block === "p" || block === "d") && num >= 57 && num <= 70)
              relativeY += getShift(num, block);
          }
          // If element is selected, draw a thicker black border
          if (e.number == selectedElement) {
            p.stroke(0);
            p.strokeWeight(3);
          } else {
            p.noStroke();
          }
          p.fill(colors[block] || "#CCCCCC");
          p.rect(relativeX, relativeY, pos.width, pos.height, 5);
          p.noStroke();
          p.fill(0);
          p.textSize(13);
          p.textStyle(p.BOLD);
          p.textAlign(p.CENTER, p.CENTER);
          p.text(e.number, relativeX + pos.width / 2, relativeY + pos.height / 2);
        }
      });
    }
    
    // Create a row for the balloon table.
    // If element is null, show "-" in both columns.
    function rowHTML(element, isCurrent) {
      if(!element) {
        return `<div style="display: table-row;">
                  <div style="display: table-cell; vertical-align: top; padding:2px; min-width:50px; border-right:1px solid lightgray;">-</div>
                  <div style="display: table-cell; vertical-align: top; padding:2px;">
                    <div style="font-size:11px; line-height:1;">-</div>
                    <div style="font-size:11px; line-height:1;">-</div>
                  </div>
                </div>`;
      }
      let atomicNumber = element.number;
      let leftCell = isCurrent 
         ? `<div style="font-size:11px; font-weight:bold; min-width:50px;">Ζ=${atomicNumber}</div>` 
         : `<div style="font-size:11px; min-width:50px;">Ζ=${atomicNumber}</div>`;
      // For the second column, we display formatted subshells only (as per specification)
      let rightCell = `<div style="display: table-cell; vertical-align: top; padding:2px;">
                         <div style="font-size:11px; line-height:1;">${getRawLine(element, isCurrent)}</div>
                         <div style="font-size:11px; line-height:1;">${getFormattedLine(element, isCurrent)}</div>
                       </div>`;
      return `<div style="display: table-row;">${leftCell}${rightCell}</div>`;
    }
    
    // Raw line: simply join the subshells.
    function getRawLine(element, isCurrent) {
      let subs = getSubshells(element);
      let text = subs.join(" ");
      return isCurrent ? "<b>" + text + "</b>" : text;
    }
    
    // Main function to show balloon overlay.
    // It creates a table with 3 rows: previous element, current element, and next element.
    function showBalloonOverlay(elementNumber) {
      let currentElement = elements.find(e => e.number == elementNumber);
      if (!currentElement) return;
      currentBalloonElement = elementNumber;
      selectedElement = elementNumber;
      
      let prevElement = getPrevElement(currentElement);
      let nextElement = getNextElement(currentElement);
      
      let tableHTML = `<div style="display: table; border-collapse: collapse;">`
                      + rowHTML(prevElement, false)
                      + rowHTML(currentElement, true)
                      + rowHTML(nextElement, false)
                      + `</div>`;
      let overlay = document.getElementById("balloonOverlay");
      overlay.innerHTML = tableHTML;
      
      let cellPos = currentCellPositions[elementNumber];
      if (!cellPos) return;
      overlay.style.visibility = "visible";
      overlay.style.opacity = "0";
      let overlayRect = overlay.getBoundingClientRect();
      let overlayWidth = overlayRect.width;
      let overlayHeight = overlayRect.height;
      let cellRight = cellPos.x + cellPos.width;
      let screenHalf = window.innerWidth / 2;
      let overlayX, overlayY;
      if (cellRight > screenHalf) {
         overlayX = cellPos.x + cellPos.width - (overlayWidth + 22);
      } else {
         overlayX = cellPos.x + cellPos.width - 5;
      }
      overlayY = cellPos.y + cellPos.height - 5;
      overlay.style.left = overlayX + "px";
      overlay.style.top = overlayY + "px";
      
      setTimeout(() => { overlay.style.opacity = "1"; }, 10);
    }
    
    // Update balloon overlay position on resize
    window.addEventListener("resize", function(){
      if(currentBalloonElement !== null && currentCellPositions[currentBalloonElement]) {
        showBalloonOverlay(currentBalloonElement);
      }
    });
    
    /* --- Data Loading --- */
    async function loadData() {
      // Βεβαιωθείτε ότι τα αρχεία elements.json και positions.json υπάρχουν στον ίδιο φάκελο
      let elementsResponse = await fetch('elements.json');
      elements = await elementsResponse.json();
      let positionsResponse = await fetch('positions.json');
      positions = await positionsResponse.json();
    }
    
    /* --- Initialize p5 Canvases --- */
    function initializeCanvases() {
      Object.keys({ s: 1, p: 1, d: 1, f: 1 }).forEach(function(block) {
        new p5(function(p) {
          let containerLeft = 0, containerTop = 0;
          p.setup = function() {
            let config = { cols: 10, rows: 7 };
            if (block === "s") config = { cols: 2, rows: 7 };
            else if (block === "p") config = { cols: 6, rows: 7 };
            else if (block === "d") config = { cols: 10, rows: 7 };
            else if (block === "f") config = { cols: 14, rows: 7 };
            let canvas = p.createCanvas(config.cols * cellSize, config.rows * cellSize);
            canvas.elt.getContext("2d", { willReadFrequently: true });
            canvas.parent("canvas" + block.toUpperCase());
            containerLeft = 0;
            containerTop = 0;
            p.skipNextClick = true;
            setTimeout(() => { p.skipNextClick = false; }, 100);
            p.mouseClicked = function(event) {
              if (p.skipNextClick) return;
              let globalX = event.clientX;
              let globalY = event.clientY;
              let found = performHitTest(globalX, globalY);
              if(found !== null){
                selectedElement = found;
                showBalloonOverlay(found);
              }
            };
          };
          p.draw = function() {
            p.clear();
            drawElements(p, block, containerLeft, containerTop);
          };
        });
      });
    }
    
    // Other canvas initialization functions (initializeSectorsCanvas, initGroupsCanvases, etc.) παραμένουν όπως στο προηγούμενο παράδειγμα.
    // Για λόγους συντομίας, θεωρούμε ότι έχετε ήδη τον κώδικα τους.
    
    window.drawElements = drawElements;
    
    // Main initialization after data load
    loadData().then(() => {
      // Ανάλογα με το mode, αρχικοποιούνται οι καμβάδες.
      if (currentMode === "expanded" || currentMode === "collapsed") {
        initializeBackgroundCanvas();
        // initializeSectorsCanvas();
        // initializePeriodsCanvas();
        // initGroupsCanvases();
        initializeCanvases();
      } else if (currentMode === "start") {
        initializeBackgroundCanvas();
        // initializeSectorsCanvas();
        initializeCanvases();
      }
      updateCellsPositions();
      console.log("Data loaded and canvases initialized.");
      if (currentMode === "start" && currentCellPositions[3]) {
        showBalloonOverlay(3);
      }
    });
    
    // Buttons event handlers
    document.getElementById('nextState').addEventListener('click', function() {
      if (currentMode !== "start") {
        console.log("Το κουμπί 'Επόμενο' λειτουργεί μόνο στην κατάσταση 'start'. Κάντε Reset για επαναφορά.");
        return;
      }
      if (currentZ < 118) {
        currentZ++;
      } else if (currentZ === 118) {
        currentZ = 119;
        extraElements["1"] = true;
      } else if (currentZ === 119) {
        currentZ = 120;
        extraElements["2"] = true;
      } else if (currentZ === 120) {
        currentZ = 121;
        showPeriods = true;
      } else if (currentZ === 121) {
        // Όταν φτάσει το 121, γίνεται expand
        // (Εδώ μπορείτε να ορίσετε άλλες ενέργειες)
        return;
      }
      initializeBackgroundCanvas();
      // initializeSectorsCanvas();
      updateCellsPositions();
      console.log("NextState: currentZ =", currentZ);
      if(currentCellPositions[currentZ]) {
         showBalloonOverlay(currentZ);
      }
    });
    
    document.getElementById('fillAll').addEventListener('click', function() {
      // Ενέργεια για πλήρη εμφάνιση (expand)
    });
    
    document.getElementById('toggleFBlock').addEventListener('click', function() {
      isCollapsed = !isCollapsed;
      this.textContent = isCollapsed ? "Ανάπτυξε" : "Σύμπτυξε";
      currentMode = isCollapsed ? "collapsed" : "expanded";
      initializeBackgroundCanvas();
      // initializeSectorsCanvas();
      updateCellsPositions();
      if(currentBalloonElement !== null && currentCellPositions[currentBalloonElement]) {
        showBalloonOverlay(currentBalloonElement);
      }
    });
    
    document.getElementById('reset').addEventListener('click', function() {
      currentMode = "start";
      currentZ = 3;
      extraElements = {};
      showPeriods = false;
      location.reload();
    });
    
    function performHitTest(x, y) {
      let region = computeModeRegionUpdated();
      if (!region) {
         console.log("Δεν εμφανίζονται στοιχεία στο τρέχον mode.");
         return null;
      }
      let regionLeft = region.minX, regionTop = region.minY;
      if (x < regionLeft || x > region.maxX || y < regionTop || y > region.maxY) {
         console.log("Κλικ εκτός περιοχής στοιχείων.");
         return null;
      }
      let relX = x - regionLeft, relY = y - regionTop;
      let offCanvas = document.getElementById("offscreenCanvas");
      offCanvas.width = region.maxX - region.minX;
      offCanvas.height = region.maxY - region.minY;
      let offCtx = offCanvas.getContext("2d");
      offCtx.clearRect(0, 0, offCanvas.width, offCanvas.height);
      for (let key in currentCellPositions) {
         let pos = currentCellPositions[key];
         let drawX = pos.x - regionLeft;
         let drawY = pos.y - regionTop;
         let num = Number(key);
         let r = (num * 37) % 256;
         let g = (num * 67) % 256;
         let b = (num * 97) % 256;
         offCtx.fillStyle = "rgb(" + r + "," + g + "," + b + ")";
         offCtx.fillRect(drawX, drawY, pos.width, pos.height);
      }
      let pixel = offCtx.getImageData(relX, relY, 1, 1).data;
      if (pixel[3] === 0) {
         console.log("Δεν ανιχνεύτηκε στοιχείο στο σημείο (" + x + ", " + y + ") μέσω color picking.");
         return null;
      } else {
         for (let key in currentCellPositions) {
            let pos = currentCellPositions[key];
            let num = Number(key);
            let r = (num * 37) % 256;
            let g = (num * 67) % 256;
            let b = (num * 97) % 256;
            if (pixel[0] === r && pixel[1] === g && pixel[2] === b) {
                return key;
            }
         }
         return null;
      }
    }
  </script>
</body>
</html>
