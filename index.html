<!DOCTYPE html>
<html lang="el">
<head>
  <meta charset="UTF-8">
  <title>Περιοδικός Πίνακας – Δική μου Λογική Βήμα Βήμα</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #f7f7f7;
      text-align: center;
    }
    #tableContainer {
      margin: 20px auto;
      width: max-content;
    }
    .rowContainer {
      display: grid;
      gap: 2px;
      margin-bottom: 5px;
    }
    .element {
      width: 50px;
      height: 50px;
      line-height: 50px;
      text-align: center;
      font-size: 14px;
      border: 1px solid #555;
      background: #ddd;
      cursor: pointer;
      user-select: none;
    }
    /* Χρώματα κατηγοριών */
    .s-block { background: #ffb3b3; }
    .d-block { background: #b3b3ff; }
    .p-block { background: #b3ffb3; }
    .f-block { background: #ffd699; }
    #electronConfig {
      max-width: 600px;
      margin: 20px auto;
      padding: 10px;
      border: 2px solid #333;
      background: #fff;
      text-align: left;
    }
    #nextElement {
      margin: 20px;
      padding: 10px 20px;
      font-size: 16px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <button id="nextElement">Επόμενο Στοιχείο</button>
  <div id="tableContainer"></div>
  <div id="electronConfig">Κάντε κλικ σε ένα στοιχείο για λεπτομέρειες</div>
  
  <script>
    /* --- Ορισμός της κατηγορίας ανά αριθμό --- */
    function getCategory(n) {
      if(n >= 3 && n <= 10) {
        return (n === 3 || n === 4) ? 's-block' : 'p-block';
      } else if(n >= 11 && n <= 18) {
        return (n === 11 || n === 12) ? 's-block' : 'p-block';
      } else if(n >= 19 && n <= 36) {
        if(n === 19 || n === 20) return 's-block';
        if(n >= 21 && n <= 30) return 'd-block';
        return 'p-block';
      } else if(n >= 37 && n <= 54) {
        if(n === 37 || n === 38) return 's-block';
        if(n >= 39 && n <= 48) return 'd-block';
        return 'p-block';
      } else if(n >= 55 && n <= 86) {
        // Group3, first row: 2 fixed (s), 14 shifting (f), then 10 fixed (d) & 6 fixed (p)
        if(n === 55 || n === 56) return 's-block';
        if(n >= 57 && n <= 70) return 'f-block';
        if(n >= 71 && n <= 80) return 'd-block';
        return 'p-block';
      } else if(n >= 87 && n <= 118) {
        if(n === 87 || n === 88) return 's-block';
        if(n >= 89 && n <= 102) return 'f-block';
        if(n >= 103 && n <= 112) return 'd-block';
        return 'p-block';
      }
      return 'p-block';
    }
    
    /* --- Δημιουργία κελιού στοιχείου --- */
    function createCell(elObj) {
      const cell = document.createElement('div');
      cell.className = 'element ' + elObj.category;
      cell.textContent = elObj.number;
      cell.addEventListener('click', () => {
        document.getElementById('electronConfig').innerHTML =
          `<strong>Στοιχείο ${elObj.number}:</strong><br>Διαμόρφωση: 1s² ... ${elObj.number}`;
      });
      return cell;
    }
    
    /* --- Ορισμός μοτίβων ανά row --- */
    // Ορίζουμε 6 rows (index 0–5) με τα παρακάτω:
    // Group1: rows 0–1: [ {count: 8, shifting: false} ]
    // Group2: rows 2–3: [ {count: 2, shifting: false}, {count: 10, shifting: true}, {count: 6, shifting: false} ]
    // Group3: rows 4–5: [ {count: 2, shifting: false}, {count: 14, shifting: true}, {count: 10, shifting: false}, {count: 6, shifting: false} ]
    const patterns = [
      [ {count: 8, shifting: false} ],
      [ {count: 8, shifting: false} ],
      [ {count: 2, shifting: false}, {count: 10, shifting: true}, {count: 6, shifting: false} ],
      [ {count: 2, shifting: false}, {count: 10, shifting: true}, {count: 6, shifting: false} ],
      [ {count: 2, shifting: false}, {count: 14, shifting: true}, {count: 10, shifting: false}, {count: 6, shifting: false} ],
      [ {count: 2, shifting: false}, {count: 14, shifting: true}, {count: 10, shifting: false}, {count: 6, shifting: false} ]
    ];
    // Ο συνολικός αριθμός στοιχείων ανά row (άθροισμα των segments):
    const totals = [8, 8, 18, 18, 32, 32];
    
    // Ορισμός Group: rows 0–1: Group1, rows 2–3: Group2, rows 4–5: Group3.
    function getGroup(rowIndex) {
      if(rowIndex < 2) return 1;
      else if(rowIndex < 4) return 2;
      else return 3;
    }
    
    // Δεδομένα για κάθε row:
    const rowsData = [];
    for(let i = 0; i < 6; i++){
      rowsData.push({
        pattern: patterns[i],
        totalCells: totals[i],
        currentSegment: 0,
        countInSegment: 0,
        cells: [],
        // Αν η τρέχουσα φάση είναι shifting, θα χρησιμοποιηθεί το insertionIndex,
        // αλλιώς για rows που επηρεάζονται από shifting του κάτω group, διατηρούμε ένα externalInsertion.
        insertionIndex: 0,
        externalInsertion: 0  // για rows με fixed μοτίβο, αρχικά θα είναι το τέλος (δηλαδή 0, αλλά ενημερώνεται καθώς προστίθενται στοιχεία)
      });
    }
    
    // Global δείκτης: ποιο στοιχείο (αριθμός) προστίθεται επόμενο.
    let globalElementNumber = 3;
    // Δείκτης για το τρέχον row (0 έως 5)
    let currentRowIndex = 0;
    
    // Βοηθητική: Εισαγωγή "κενής" στήλης (null) σε συγκεκριμένες rows στο κατάλληλο insertion index.
    function insertShiftedColumnForRows(rowIndices, colProvider) {
      rowIndices.forEach(i => {
        const row = rowsData[i];
        // Αν ο row είναι σε shifting φάση, χρησιμοποιούμε το insertionIndex, αλλιώς το τέλος.
        let idx = 0;
        const seg = (row.currentSegment < row.pattern.length) ? row.pattern[row.currentSegment] : null;
        if(seg && seg.shifting) {
          idx = row.insertionIndex;
          row.cells.splice(idx, 0, null);
          row.insertionIndex++;
        } else {
          idx = row.cells.length;
          row.cells.splice(idx, 0, null);
          row.externalInsertion = row.cells.length;
        }
      });
    }
    
    // Συνάρτηση για προσθήκη του επόμενου στοιχείου στο τρέχον row σύμφωνα με το μοτίβο.
    function addElementToCurrentRow() {
      if(currentRowIndex >= rowsData.length) return; // Όλα τελειώσαν
      
      const row = rowsData[currentRowIndex];
      const pattern = row.pattern;
      const segment = pattern[row.currentSegment];
      
      // Δημιουργούμε το στοιχείο
      const elObj = {
        number: globalElementNumber,
        category: getCategory(globalElementNumber)
      };
      const cell = createCell(elObj);
      
      // Έλεγχος αν η τρέχουσα φάση είναι shifting
      if(segment.shifting) {
        // Προσδιορίζουμε το insertion index για το row (για το shifting)
        // Πριν την εισαγωγή, ενημερώνουμε τις "άνω" σειρές ανάλογα με το group.
        const group = getGroup(currentRowIndex);
        if(group === 2) {
          // Για group2, επηρεάζουμε τις σειρές της Group1 (rows 0–1)
          insertShiftedColumnForRows([0,1], () => {}); // η συνάρτηση colProvider δεν χρειάζεται εδώ
        } else if(group === 3) {
          // Για group3, επηρεάζουμε τις σειρές της Group1 και Group2 (rows 0–3)
          insertShiftedColumnForRows([0,1,2,3], () => {});
        }
        // Τώρα, στην τρέχουσα γραμμή, εισάγουμε το στοιχείο στη θέση insertionIndex
        row.cells.splice(row.insertionIndex, 0, cell);
        row.insertionIndex++;
      } else {
        // Fixed: απλή προσθήκη στο τέλος
        row.cells.push(cell);
        // Επίσης, αν δεν είμαστε σε shifting φάση, το externalInsertion μπορεί να ενημερώνεται ως το τέλος
        row.externalInsertion = row.cells.length;
      }
      
      row.countInSegment++;
      globalElementNumber++;
      
      // Αν ολοκληρώθηκε το τμήμα, μεταβαίνουμε στο επόμενο
      if(row.countInSegment === segment.count) {
        row.currentSegment++;
        row.countInSegment = 0;
        // Αν υπάρχει επόμενο τμήμα και είναι shifting, ορίζουμε το insertionIndex στο τέλος της γραμμής
        if(row.currentSegment < pattern.length && pattern[row.currentSegment].shifting) {
          row.insertionIndex = row.cells.length;
        }
      }
      
      // Εάν η τρέχουσα γραμμή έχει συμπληρωθεί (έφτασε το πλήθος κελιών σύμφωνα με το pattern)
      if(row.cells.length >= row.totalCells) {
        currentRowIndex++;
      }
    }
    
    // Συνάρτηση που καλείται με το πάτημα του κουμπιού "Επόμενο Στοιχείο"
    function addNextElement() {
      if(globalElementNumber > 118 || currentRowIndex >= rowsData.length) {
        document.getElementById('nextElement').disabled = true;
        return;
      }
      addElementToCurrentRow();
      renderAllRows();
    }
    
    document.getElementById('nextElement').addEventListener('click', addNextElement);
    
    // Συνάρτηση απόδοσης (render) όλων των rows
    function renderAllRows() {
      const container = document.getElementById('tableContainer');
      container.innerHTML = '';
      rowsData.forEach(row => {
        const rowDiv = document.createElement('div');
        rowDiv.className = 'rowContainer';
        // Ορίζουμε το grid να έχει τόσες στήλες όσα τα κελιά στην τρέχουσα γραμμή
        rowDiv.style.gridTemplateColumns = `repeat(${row.cells.length}, 50px)`;
        row.cells.forEach(cell => {
          // Εάν το κελί είναι null, δημιουργούμε ένα κενό div για στοίχιση.
          if(cell === null) {
            const emptyDiv = document.createElement('div');
            emptyDiv.className = 'element';
            emptyDiv.style.background = '#fff';
            rowDiv.appendChild(emptyDiv);
          } else {
            rowDiv.appendChild(cell);
          }
        });
        container.appendChild(rowDiv);
      });
    }
    
    // Αρχική απόδοση
    renderAllRows();
  </script>
</body>
</html>
