<!DOCTYPE html>
<html lang="el">
<head>
  <meta charset="UTF-8">
  <title>Περιοδικός Πίνακας με Complex Balloon Overlay</title>
  <link href="https://fonts.googleapis.com/css?family=Roboto&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
  <style>
    body { 
      font-family: 'Roboto', sans-serif; 
      margin: 0; 
      overflow: hidden; 
      background: #f7f7f7; 
    }
    .canvas { 
      position: absolute; 
      background: transparent; 
      transition: all 0.5s ease-in-out; 
    }
    canvas {
      padding: 8px;
      filter: drop-shadow(4px 4px 4px rgba(0,0,0,0.5));
      overflow: visible;
    }
    /* Background canvas */
    #canvasTableBackground {
      position: absolute; 
      background: white; 
      border: 1px solid rgba(0,0,0,0.1);
      box-shadow: 6px 6px 10px rgba(0,0,0,0.3); 
      z-index: -10;
      opacity: 1;
      transition: all 0.5s ease-in-out;
    }
    /* Group canvases */
    #canvasS_groups, #canvasD_groups, #canvasP_groups { 
      position: absolute;
      z-index: 60;
    }
    /* Sector canvases */
    #canvasS { z-index: 10; }
    #canvasF { z-index: 20; }
    #canvasD { z-index: 30; }
    #canvasP { z-index: 40; }
    #canvasPeriods { z-index: 50; }
    /* Button panel */
    #buttonPanel {
      position: fixed; 
      bottom: 20px; 
      right: 20px;
      z-index: 100;
      display: flex; 
      flex-direction: column;
      gap: 5px;
    }
    #buttonPanel button {
      background-color: #008CBA; 
      color: white; 
      padding: 10px 15px;
      border: none; 
      border-radius: 5px;
      cursor: pointer;
      box-shadow: 4px 4px 4px rgba(0,0,0,0.5);
    }
    /* Offscreen canvas για color picking */
    #offscreenCanvas { display: none; }
    /* Στυλ για το balloon overlay */
    #balloonOverlay {
      position: absolute;
      background: white;
      border: 1px solid rgba(0,0,0,0.2);
      box-shadow: 2px 2px 6px rgba(0,0,0,0.3);
      padding: 6px 8px;
      border-radius: 5px;
      z-index: 150;
      visibility: hidden;
      opacity: 0;
      transition: opacity 0.3s ease;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <!-- Καμβάδες -->
  <div id="canvasTableBackground"></div>
  <div id="canvasS_groups" class="canvas"></div>
  <div id="canvasD_groups" class="canvas"></div>
  <div id="canvasP_groups" class="canvas"></div>
  
  <div id="canvasPeriods" class="canvas"></div>
  <div id="canvasS" class="canvas"></div>
  <div id="canvasD" class="canvas"></div>
  <div id="canvasP" class="canvas"></div>
  <div id="canvasF" class="canvas"></div>

  <!-- Κουμπιά -->
  <div id="buttonPanel">
    <button id="nextState">Επόμενο</button>
    <button id="fillAll">Συμπλήρωσε</button>
    <button id="toggleFBlock" disabled>Σύμπτυξε</button>
    <button id="reset">Reset</button>
  </div>
  
  <!-- Offscreen canvas για color picking -->
  <canvas id="offscreenCanvas" width="800" height="600"></canvas>
  
  <!-- Balloon overlay -->
  <div id="balloonOverlay"></div>

  <script>
    // Global variables
    let elements = [];
    let positions = {};
    let isCollapsed = false;
    let currentMode = "start";
    let currentZ = 3;
    let extraElements = {};  
    let showPeriods = false;
    let cellSize = 40;
    let currentCellPositions = {};
    let currentBalloonElement = null; // Αποθηκεύει το στοιχείο που έχει επιλεγεί για το balloon

    // Χρώματα τομέα
    let sectorColors = { s: "#FF477E", p: "#26FF31", d: "#3F99FF", f: "#FFD051" };

    /* Βοηθητικές συναρτήσεις μετατόπισης, υπολογισμού περιοχής κλπ. (ίδιες όπως πριν) */
    function getShift(num, block) {
      if (currentMode !== "start") return 0;
      if (block === "p" && num >= 21 && num <= 30) {
        let effectiveZ = Math.min(currentZ, 30);
        return (effectiveZ - 20) * 42;
      }
      if ((block === "p" || block === "d") && num >= 57 && num <= 70) {
        let effective = Math.min(currentZ, 70);
        return (effective - 56) * 42;
      }
      return 0;
    }
    function getShiftContainer(block) {
      if (currentMode !== "start") return 0;
      if (block === "p") {
        if (currentZ <= 20) return 0;
        else if (currentZ <= 30) return (currentZ - 20) * 42;
        else if (currentZ <= 56) return (30 - 20) * 42;
        else if (currentZ <= 70) return (30 - 20) * 42 + (currentZ - 56) * 42;
        else return (30 - 20) * 42 + (70 - 56) * 42;
      } else if (block === "d") {
        if (currentZ < 57) return 0;
        else if (currentZ <= 70) return (currentZ - 56) * 42;
        else return (70 - 56) * 42;
      }
      return 0;
    }
    function computeModeRegion() {
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      elements.forEach(e => {
        let num = Number(e.number);
        if (currentMode === "start") {
          if ((num < 3 && !extraElements[num]) || num > currentZ) return;
        }
        let pos = positions[currentMode][e.number] ||
                  ((e.number === "1" || e.number === "2") ? positions["start"][e.number] : null);
        if (pos) {
          let x = pos.x, y = pos.y;
          if (currentMode === "start" && (e.block === "p" || e.block === "d")) {
            x += getShiftContainer(e.block);
            if (e.block === "p" && num >= 21 && num <= 30)
              y += getShift(num, e.block);
            else if ((e.block === "p" || e.block === "d") && num >= 57 && num <= 70)
              y += getShift(num, e.block);
          }
          minX = Math.min(minX, x);
          minY = Math.min(minY, y);
          maxX = Math.max(maxX, x + pos.width);
          maxY = Math.max(maxY, y + pos.height);
        }
      });
      return (minX === Infinity) ? null : { minX, minY, maxX, maxY };
    }
    function updateCellsPositions() {
      currentCellPositions = {};
      elements.forEach(e => {
        let num = Number(e.number);
        if (currentMode === "start") {
          if ((num < 3 && !extraElements[num]) || num > currentZ) return;
        }
        let pos = positions[currentMode][e.number] ||
                  (((e.number === "1" || e.number === "2") && extraElements[e.number]) ? positions["start"][e.number] : null);
        if (!pos) return;
        let offsetX = 0, offsetY = 0;
        if (currentMode === "start" && (e.block === "p" || e.block === "d")) {
          offsetX = getShiftContainer(e.block);
        }
        if (currentMode === "start") {
          if (e.block === "p" && num >= 21 && num <= 30)
            offsetY = getShift(num, e.block);
          else if ((e.block === "p" || e.block === "d") && num >= 57 && num <= 70)
            offsetY = getShift(num, e.block);
        }
        currentCellPositions[e.number] = {
          x: pos.x + offsetX,
          y: pos.y + offsetY,
          width: pos.width,
          height: pos.height
        };
      });
    }
    function computeModeRegionUpdated() {
      let keys = Object.keys(currentCellPositions);
      if (keys.length === 0) return null;
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      for (let key in currentCellPositions) {
        let pos = currentCellPositions[key];
        minX = Math.min(minX, pos.x);
        minY = Math.min(minY, pos.y);
        maxX = Math.max(maxX, pos.x + pos.width);
        maxY = Math.max(maxY, pos.y + pos.height);
      }
      return { minX, minY, maxX, maxY };
    }
    function initializeBackgroundCanvas() {
      let bg = document.getElementById("canvasTableBackground");
      let margin = 20;
      if (currentMode === "start") {
        let limits = computeModeRegion();
        if (limits) {
          bg.style.left = "17px";
          bg.style.top = (limits.minY - margin) + "px";
          let width = (limits.maxX - 17) + margin;
          bg.style.width = width + "px";
          bg.style.height = (limits.maxY - limits.minY + 2 * margin) + "px";
        }
      } else if (currentMode === "expanded" || currentMode === "collapsed") {
        let leftFixed = 17, topFixed = 55;
        let margin = 20;
        let limits = computeModeRegion();
        let rightLimit = limits.maxX + margin;
        let bottomLimit = limits.maxY + margin;
        bg.style.left = leftFixed + "px";
        bg.style.top = topFixed + "px";
        bg.style.width = (rightLimit - leftFixed) + "px";
        bg.style.height = (bottomLimit - topFixed) + "px";
      }
      bg.style.opacity = "1";
    }
    async function loadData() {
      let resElements = await fetch('elements.json');
      elements = await resElements.json();
      let resPositions = await fetch('positions.json');
      positions = await resPositions.json();
    }
    function initializePeriodsCanvas() {
      new p5(function(p) {
        p.setup = function() {
          let canvas = p.createCanvas(40, 292);
          canvas.parent("canvasPeriods");
          let container = document.getElementById("canvasPeriods");
          let bgLeft = parseInt(document.getElementById("canvasTableBackground").style.left);
          container.style.left = (bgLeft + 6) + "px";
          container.style.top = positions[currentMode]["1"].y + "px";
          p.noStroke();
          p.textAlign(p.CENTER, p.CENTER);
          p.textSize(11);
          p.textStyle(p.BOLD);
          const periodLabels = ["1η K", "2η L", "3η M", "4η N", "5η O", "6η Ρ", "7η Q"];
          for (let i = 0; i < 7; i++) {
            p.fill(240);
            p.rect(0, i * 42, 40, 40);
            p.fill(0);
            p.text(periodLabels[i], 20, i * 42 + 20);
          }
        };
      });
    }
    function initGroupsCanvases() {
      new p5(function(p) {
        p.setup = function() {
          let canvas = p.createCanvas(82, 40);
          canvas.parent("canvasS_groups");
          p.background(240);
          for (let col = 0; col < 2; col++) {
            p.noStroke();
            p.noFill();
            p.rect(col * 42, 0, 40, 20);
            p.rect(col * 42, 20, 40, 20);
          }
          p.noStroke();
          p.fill(0);
          p.textAlign(p.CENTER, p.CENTER);
          p.textSize(11);
          p.textStyle(p.BOLD);
          p.text("1", 20, 10);
          p.text("2", 20 + 42, 10);
          p.text("IA", 20, 30);
          p.text("IIA", 20 + 42, 30);
        };
      });
      new p5(function(p) {
        p.setup = function() {
          let canvas = p.createCanvas(418, 40);
          canvas.parent("canvasD_groups");
          p.background(240);
          for (let col = 0; col < 10; col++) {
            p.noStroke();
            p.noFill();
            p.rect(col * 42, 0, 40, 20);
            p.rect(col * 42, 20, 40, 20);
          }
          p.noStroke();
          p.fill(0);
          p.textAlign(p.CENTER, p.CENTER);
          p.textSize(11);
          p.textStyle(p.BOLD);
          for (let c = 0; c < 10; c++) {
            let x = c * 42;
            p.text((c + 3).toString(), x + 20, 10);
          }
          const oldLabels = ["IIIB", "IVB", "VB", "VIB", "VIIB", "VIIIB", "VIIIB", "VIIIB", "IB", "IIB"];
          for (let c = 0; c < 10; c++) {
            let x = c * 42;
            p.text(oldLabels[c], x + 20, 30);
          }
        };
      });
      new p5(function(p) {
        p.setup = function() {
          let canvas = p.createCanvas(250, 40);
          canvas.parent("canvasP_groups");
          p.background(240);
          for (let col = 0; col < 6; col++) {
            p.noStroke();
            p.noFill();
            p.rect(col * 42, 0, 40, 20);
            p.rect(col * 42, 20, 40, 20);
          }
          p.noStroke();
          p.fill(0);
          p.textAlign(p.CENTER, p.CENTER);
          p.textSize(11);
          p.textStyle(p.BOLD);
          for (let c = 0; c < 6; c++) {
            let x = c * 42;
            p.text((c + 13).toString(), x + 20, 10);
          }
          const oldLabels = ["IIIA", "IVA", "VA", "VIA", "VIIA", "VIIIA"];
          for (let c = 0; c < 6; c++) {
            let x = c * 42;
            p.text(oldLabels[c], x + 20, 30);
          }
        };
      });
      ["S", "D", "P"].forEach(sector => {
        let sectorCanvas = document.getElementById("canvas" + sector);
        let groupCanvas = document.getElementById("canvas" + sector + "_groups");
        groupCanvas.style.left = sectorCanvas.style.left;
        groupCanvas.style.top = (parseInt(positions[currentMode]["1"].y) - 42 - 2) + "px";
      });
    }
    
    /* Νέες συναρτήσεις για την επιλογή στοιχείων προς το balloon overlay:
       - getAboveElement: επιστρέφει το στοιχείο στην ίδια στήλη, πάνω από το τρέχον.
       - getRightElement: επιστρέφει το στοιχείο στην ίδια γραμμή, στα δεξιά του τρέχοντος.
    */
    function getAboveElement(currentElement) {
      return elements.find(e => e.col == currentElement.col && e.block == currentElement.block && e.row == currentElement.row - 1) || null;
    }
    function getRightElement(currentElement) {
      return elements.find(e => e.row == currentElement.row && e.block == currentElement.block && e.col == currentElement.col + 1) || null;
    }
    
    /* Η νέα συνάρτηση rowHTML που δημιουργεί μια γραμμή (ένα στοιχείο) του πίνακα του balloon.
       Η αριστερή στήλη εμφανίζει το "Ζ=" + αριθμό, και η δεξιά στήλη δύο γραμμές:
       - Η πρώτη με τις απλές υποστιβάδες.
       - Η δεύτερη με τις στιβάδες, εφαρμόζοντας τα χρώματα του τομέα.
    */
    function rowHTML(element, isCurrent) {
      if (!element) {
        return `<div style="display: table-row; line-height:1.2;">
                  <div style="display: table-cell; vertical-align: top; padding:2px; min-width:50px; border-right:1px solid lightgray;">-</div>
                  <div style="display: table-cell; vertical-align: top; padding:2px;">-</div>
                </div>`;
      }
      let atomicNumberText = isCurrent ? `<b>Ζ=${element.number}</b>` : `Ζ=${element.number}`;
      let subs = getSubshells(element);
      let simpleLine = "";
      if (subs.length > 0) {
        simpleLine = isCurrent 
          ? `<b>${subs.join(" ")}</b>`
          : subs.slice(0, subs.length - 1).join(" ") + " <b>" + subs[subs.length - 1] + "</b>";
      }
      let shells = subs.map(s => formatSubshell(s));
      let formattedLine = "";
      if (shells.length > 0) {
        // Για το τρέχον στοιχείο, στις στιβάδες μόνο η τελευταία είναι bold.
        formattedLine = shells.slice(0, shells.length - 1).join(" ") + " " + "<b>" + shells[shells.length - 1] + "</b>";
      }
      let colorStyle = sectorColors[element.block] ? `color: ${sectorColors[element.block]};` : "";
      return `<div style="display: table-row; line-height:1.2;">
                <div style="display: table-cell; vertical-align: top; padding:2px; min-width:50px; border-right:1px solid lightgray;">${atomicNumberText}</div>
                <div style="display: table-cell; vertical-align: top; padding:2px; font-size:11px;">
                  <div>${simpleLine}</div>
                  <div style="margin-top:2px; ${colorStyle}">${formattedLine}</div>
                </div>
              </div>`;
    }
    
    /* Η συνάρτηση showBalloonOverlay χρησιμοποιεί τις νέες getAboveElement και getRightElement για να δημιουργήσει ένα πίνακα 3 γραμμών:
       - Πάνω στοιχείο (αν υπάρχει)
       - Τρέχον στοιχείο
       - Δεξί στοιχείο (αν υπάρχει)
    */
    function showBalloonOverlay(elementNumber) {
      let currentElement = elements.find(e => e.number == elementNumber);
      if (!currentElement) return;
      currentBalloonElement = elementNumber;
      let aboveElement = getAboveElement(currentElement);
      let rightElement = getRightElement(currentElement);
      let tableHTML = `<div style="display: table; border-collapse: collapse;">`
                      + rowHTML(aboveElement, false)
                      + rowHTML(currentElement, true)
                      + rowHTML(rightElement, false)
                      + `</div>`;
      let overlay = document.getElementById("balloonOverlay");
      overlay.innerHTML = tableHTML;
      let cellPos = currentCellPositions[elementNumber];
      if (!cellPos) return;
      overlay.style.visibility = "visible";
      overlay.style.opacity = "0";
      let overlayRect = overlay.getBoundingClientRect();
      let overlayWidth = overlayRect.width;
      let cellRight = cellPos.x + cellPos.width;
      let screenHalf = window.innerWidth / 2;
      let overlayX = (cellRight > screenHalf) ? (cellPos.x + cellPos.width - (overlayWidth + 22)) : (cellPos.x + cellPos.width - 5);
      let overlayY = cellPos.y + cellPos.height - 5;
      overlay.style.left = overlayX + "px";
      overlay.style.top = overlayY + "px";
      setTimeout(() => { overlay.style.opacity = "1"; }, 10);
    }
    
    /* Σχεδίαση στοιχείων στο p5 canvas – αν το στοιχείο είναι το τρέχον (currentBalloonElement) το περίγραμμά του γίνεται με strokeWeight 3.
       Το bold περίγραμμα αλλάζει είτε με κλικ είτε με το "Επόμενο", και όταν γίνεται εναλλαγή collapse/expand.
    */
    function drawElements(p, block, containerLeft, containerTop) {
      let colors = { s: "#FF477E", p: "#26FF31", d: "#3F99FF", f: "#FFD051" };
      elements.filter(e => e.block === block).forEach(e => {
        let num = Number(e.number);
        if (currentMode === "start") {
          if ((num < 3 && !extraElements[num]) || num > currentZ) return;
        }
        let pos = positions[currentMode][e.number] ||
                  ((e.number === "1" || e.number === "2") ? positions["start"][e.number] : null);
        if (pos) {
          let relativeX = pos.x - containerLeft;
          let relativeY = pos.y - containerTop;
          if (currentMode === "start") {
            if (block === "p" && num >= 21 && num <= 30)
              relativeY += getShift(num, block);
            else if ((block === "p" || block === "d") && num >= 57 && num <= 70)
              relativeY += getShift(num, block);
          }
          if (currentBalloonElement == e.number) { 
              p.strokeWeight(3); 
              p.stroke(0); 
          } else { 
              p.noStroke(); 
          }
          p.fill(colors[block] || "#CCCCCC");
          p.rect(relativeX, relativeY, pos.width, pos.height, 5);
          p.noStroke();
          p.fill(0);
          p.textSize(13);
          p.textStyle(p.BOLD);
          p.textAlign(p.CENTER, p.CENTER);
          p.text(e.number, relativeX + pos.width / 2, relativeY + pos.height / 2);
        }
      });
    }
    
    /* Ενημέρωση του "Επόμενου" κουμπιού:
       Αν υπάρχει στοιχείο στα δεξιά (μέσω getRightElement) του τρέχοντος, τότε αυτό γίνεται νέο τρέχον.
       Έτσι, όταν το "Επόμενο" πατιέται, το bold περίγραμμα μετακινείται στο κελί που έγινε κλικ (δηλαδή το τρέχον στοιχείο).
    */
    document.getElementById('nextState').addEventListener('click', function() {
      if (currentMode !== "start") {
        console.log("Το κουμπί 'Επόμενο' λειτουργεί μόνο στην κατάσταση 'start'. Κάντε Reset για επαναφορά.");
        return;
      }
      let currentElement = elements.find(e => e.number == currentBalloonElement) || elements.find(e => e.number == currentZ);
      if (!currentElement) return;
      let rightElement = getRightElement(currentElement);
      if (rightElement) {
        currentZ = rightElement.number;
        currentBalloonElement = rightElement.number;
        showBalloonOverlay(currentBalloonElement);
      } else {
        // Αν δεν υπάρχει δεξί στοιχείο, μπορεί να γίνει μετάβαση σε πλήρη εμφάνιση:
        fillAllAction();
      }
    });
    
    document.getElementById('fillAll').addEventListener('click', function() { fillAllAction(); });
    document.getElementById('toggleFBlock').addEventListener('click', function() {
      isCollapsed = !isCollapsed;
      this.textContent = isCollapsed ? "Ανάπτυξε" : "Σύμπτυξε";
      currentMode = isCollapsed ? "collapsed" : "expanded";
      initializeBackgroundCanvas();
      initializeSectorsCanvas();
      ["S", "D", "P"].forEach(sector => {
        let sectorCanvas = document.getElementById("canvas" + sector);
        let groupCanvas = document.getElementById("canvas" + sector + "_groups");
        groupCanvas.style.left = sectorCanvas.style.left;
        groupCanvas.style.top = (parseInt(positions[currentMode]["1"].y) - 42 - 2) + "px";
      });
      updateCellsPositions();
      if(currentBalloonElement !== null && currentCellPositions[currentBalloonElement]) {
        showBalloonOverlay(currentBalloonElement);
      }
    });
    document.getElementById('reset').addEventListener('click', function() {
      currentMode = "start";
      currentZ = 3;
      extraElements = {};
      showPeriods = false;
      location.reload();
    });
    window.addEventListener("resize", function(){
      if(currentBalloonElement !== null && currentCellPositions[currentBalloonElement]) {
        showBalloonOverlay(currentBalloonElement);
      }
    });
    
    function initializeCanvases() {
      Object.keys({ s: 1, p: 1, d: 1, f: 1 }).forEach(function(block) {
        new p5(function(p) {
          p.setup = function() {
            let config = { cols: 10, rows: 7 };
            if (block === "s") config = { cols: 2, rows: 7 };
            else if (block === "p") config = { cols: 6, rows: 7 };
            else if (block === "d") config = { cols: 10, rows: 7 };
            else if (block === "f") config = { cols: 14, rows: 7 };
            let canvas = p.createCanvas(config.cols * cellSize, config.rows * cellSize);
            canvas.elt.getContext("2d", { willReadFrequently: true });
            canvas.parent("canvas" + block.toUpperCase());
            p.skipNextClick = true;
            setTimeout(() => { p.skipNextClick = false; }, 100);
            p.mouseClicked = function(event) {
              if (p.skipNextClick) return;
              let globalX = event.clientX;
              let globalY = event.clientY;
              let found = performHitTest(globalX, globalY);
              if(found !== null){
                showBalloonOverlay(found);
              }
            };
            window.drawElements(p, block);
          };
        });
      });
    }
    window.drawElements = drawElements;
    
    loadData().then(() => {
      if (currentMode === "expanded" || currentMode === "collapsed") {
        initializeBackgroundCanvas();
        initializeSectorsCanvas();
        initializePeriodsCanvas();
        initGroupsCanvases();
        initializeCanvases();
      } else if (currentMode === "start") {
        initializeBackgroundCanvas();
        initializeSectorsCanvas();
        initializeCanvases();
      }
      updateCellsPositions();
      if (currentMode === "start" && currentCellPositions[3]) {
        showBalloonOverlay(3);
      }
    });
  </script>
</body>
</html>
