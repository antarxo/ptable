<!DOCTYPE html>
<html lang="el">
<head>
  <meta charset="UTF-8">
  <title>Περιοδικός Πίνακας - Κώδικας με Hit Testing και Νέα Λογική "Επόμενο"</title>
  <link href="https://fonts.googleapis.com/css?family=Roboto&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
  <style>
    body { 
      font-family: 'Roboto', sans-serif; 
      margin: 0; 
      overflow: hidden; 
      background: #f7f7f7; 
    }
    .canvas { 
      position: absolute; 
      background: transparent; 
      transition: all 0.5s ease-in-out; 
    }
    canvas {
      padding: 8px;
      filter: drop-shadow(4px 4px 4px rgba(0,0,0,0.5));
      overflow: visible;
    }
    /* Background canvas με ελαφριά σκιά */
    #canvasTableBackground {
      position: absolute; 
      background: white; 
      border: 1px solid rgba(0,0,0,0.1);
      box-shadow: 6px 6px 10px rgba(0,0,0,0.3); 
      z-index: -10;
      opacity: 1;
      transition: all 0.5s ease-in-out;
    }
    /* Ομαδοποίηση καμβάδων ομάδων με υψηλό z-index */
    #canvasS_groups, #canvasD_groups, #canvasP_groups { 
      position: absolute;
      z-index: 60;
    }
    /* Καμβάδες τομέων και περιοχών */
    #canvasS { z-index: 10; }
    #canvasF { z-index: 20; }
    #canvasD { z-index: 30; }
    #canvasP { z-index: 40; }
    #canvasPeriods { z-index: 50; }
    /* Διάταξη κουμπιών */
    #buttonPanel {
      position: fixed; 
      bottom: 20px; 
      right: 20px;
      z-index: 100;
      display: flex; 
      flex-direction: column;
      gap: 5px;
    }
    #buttonPanel button {
      background-color: #008CBA; 
      color: white; 
      padding: 10px 15px;
      border: none; 
      border-radius: 5px;
      cursor: pointer;
      box-shadow: 4px 4px 4px rgba(0,0,0,0.5);
    }
    /* Offscreen canvas για color picking (προσωρινό) */
    #offscreenCanvas { display: none; }
    /* Πίνακας "Χρωμάτων" για εμφάνιση θέσεων */
    #colorTable {
      position: fixed; 
      bottom: 20px; 
      left: 20px; 
      background: #fff; 
      padding: 10px; 
      border: 1px solid #ccc; 
      max-height: 200px; 
      overflow: auto;
      font-size: 12px;
      z-index: 110;
    }
  </style>
</head>
<body>

  <!-- Καμβάδες -->
  <div id="canvasTableBackground"></div>
  <div id="canvasS_groups" class="canvas"></div>
  <div id="canvasD_groups" class="canvas"></div>
  <div id="canvasP_groups" class="canvas"></div>
  
  <div id="canvasPeriods" class="canvas"></div>
  <div id="canvasS" class="canvas"></div>
  <div id="canvasD" class="canvas"></div>
  <div id="canvasP" class="canvas"></div>
  <div id="canvasF" class="canvas"></div>

  <!-- Κουμπιά: Επόμενο, Συμπλήρωσε, Σύμπτυξε/Ανάπτυξε, Reset -->
  <div id="buttonPanel">
    <button id="nextState">Επόμενο</button>
    <button id="fillAll">Συμπλήρωσε</button>
    <button id="toggleFBlock" disabled>Σύμπτυξε</button>
    <button id="reset">Reset</button>
  </div>
  
  <!-- Offscreen canvas για color picking -->
  <canvas id="offscreenCanvas" width="800" height="600"></canvas>

  <!-- Πίνακας Χρωμάτων για εμφάνιση θέσεων -->
  <div id="colorTable"></div>

  <script>
    // Global Variables
    let elements = [];
    let positions = {};
    let isCollapsed = false;
    // Αρχική κατάσταση: mode "start" με currentZ = 3 ώστε να εμφανίζεται τουλάχιστον το στοιχείο 3
    let currentMode = "start";
    let currentZ = 3;
    // Οι μεταβλητές για post filling (extraElements και showPeriods) θα χρησιμοποιηθούν για τα στοιχεία 1,2 και την εμφάνιση περιόδων.
    let extraElements = {};  // extraElements["1"] και extraElements["2"]
    let showPeriods = false;
    let cellSize = 40; // Μέγεθος κάθε κελιού

    // Global object για αποθήκευση των θέσεων (μόνο των εμφανιζόμενων στοιχείων)
    let currentCellPositions = {};

    // Συναρτήσεις μετατόπισης
    function getShift(num, block) {
      if (currentMode !== "start") return 0;
      if (block === "p" && num >= 21 && num <= 30) {
        let effectiveZ = Math.min(currentZ, 30);
        return (effectiveZ - 20) * 42;
      }
      if ((block === "p" || block === "d") && num >= 57 && num <= 70) {
        let effective = Math.min(currentZ, 70);
        return (effective - 56) * 42;
      }
      return 0;
    }
    
    function getShiftContainer(block) {
      if (currentMode !== "start") return 0;
      if (block === "p") {
        if (currentZ <= 20) return 0;
        else if (currentZ <= 30) return (currentZ - 20) * 42;
        else if (currentZ <= 56) return (30 - 20) * 42;
        else if (currentZ <= 70) return (30 - 20) * 42 + (currentZ - 56) * 42;
        else return (30 - 20) * 42 + (70 - 56) * 42;
      } else if (block === "d") {
        if (currentZ < 57) return 0;
        else if (currentZ <= 70) return (currentZ - 56) * 42;
        else return (70 - 56) * 42;
      }
      return 0;
    }
    
    // Υπολογισμός bounding box για όλα τα εμφανιζόμενα στοιχεία (χωρίς διαχωρισμό των blocks)
    function computeModeRegion() {
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      elements.forEach(e => {
        let num = Number(e.number);
        // Στη "start" εμφανίζονται μόνο τα στοιχεία 3 έως currentZ, εκτός εάν ενεργοποιηθούν 1 και 2
        if (currentMode === "start") {
          if ((num < 3 && !extraElements[num]) || num > currentZ) return;
        }
        let pos = positions[currentMode][e.number] || ((e.number === "1" || e.number === "2") ? positions["start"][e.number] : null);
        if (pos) {
          let x = pos.x;
          let y = pos.y;
          if (currentMode === "start" && (e.block === "p" || e.block === "d")) {
            x += getShiftContainer(e.block);
            if (e.block === "p" && num >= 21 && num <= 30)
              y += getShift(num, e.block);
            else if ((e.block === "p" || e.block === "d") && num >= 57 && num <= 70)
              y += getShift(num, e.block);
          }
          minX = Math.min(minX, x);
          minY = Math.min(minY, y);
          maxX = Math.max(maxX, x + pos.width);
          maxY = Math.max(maxY, y + pos.height);
        }
      });
      return (minX === Infinity) ? null : { minX, minY, maxX, maxY };
    }

    // Ενημέρωση των θέσεων για hit-testing – καταγράφει μόνο τα εμφανιζόμενα στοιχεία
    function updateCellsPositions() {
      currentCellPositions = {};
      elements.forEach(e => {
        let num = Number(e.number);
        if (currentMode === "start") {
          if ((num < 3 && !extraElements[num]) || num > currentZ) return;
        }
        let pos = positions[currentMode][e.number] || (((e.number === "1" || e.number === "2") && extraElements[e.number]) ? positions["start"][e.number] : null);
        if (!pos) return;
        let offsetX = 0, offsetY = 0;
        if (currentMode === "start" && (e.block === "p" || e.block === "d")) {
          offsetX = getShiftContainer(e.block);
        }
        if (currentMode === "start") {
          if (e.block === "p" && num >= 21 && num <= 30)
            offsetY = getShift(num, e.block);
          else if ((e.block === "p" || e.block === "d") && num >= 57 && num <= 70)
            offsetY = getShift(num, e.block);
        }
        currentCellPositions[e.number] = {
          x: pos.x + offsetX,
          y: pos.y + offsetY,
          width: pos.width,
          height: pos.height
        };
      });
      updateColorTable();
    }

    // Ενημέρωση του πίνακα "χρωμάτων" ώστε να εμφανίζονται ΜΟΝΟ τα στοιχεία που έχουν εμφανιστεί μέχρι τη στιγμή του κλικ
    function updateColorTable() {
      let tableDiv = document.getElementById("colorTable");
      let html = "<h4>Πίνακας Χρωμάτων</h4><ul>";
      for (let key in currentCellPositions) {
        let pos = currentCellPositions[key];
        html += "<li>Στοιχείο " + key + ": x=" + pos.x + ", y=" + pos.y + ", w=" + pos.width + ", h=" + pos.height + "</li>";
      }
      html += "</ul>";
      tableDiv.innerHTML = html;
    }

    // Υπολογισμός bounding box βάσει των ενημερωμένων θέσεων
    function computeModeRegionUpdated() {
      let keys = Object.keys(currentCellPositions);
      if (keys.length === 0) return null;
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      for (let key in currentCellPositions) {
        let pos = currentCellPositions[key];
        minX = Math.min(minX, pos.x);
        minY = Math.min(minY, pos.y);
        maxX = Math.max(maxX, pos.x + pos.width);
        maxY = Math.max(maxY, pos.y + pos.height);
      }
      return { minX, minY, maxX, maxY };
    }
    
    // Ενημέρωση του background με margin 20px από όλες τις πλευρές, με left σταθερό στο 17px.
    function initializeBackgroundCanvas() {
      let bg = document.getElementById("canvasTableBackground");
      let margin = 20;
      if (currentMode === "start") {
        let limits = computeModeRegion();
        if (limits) {
          bg.style.left = "17px";
          bg.style.top = (limits.minY - margin) + "px";
          // Υπολογισμός width: το διάστημα από 17 έως το maxX + margin
          let width = (limits.maxX - 17) + margin;
          bg.style.width = width + "px";
          bg.style.height = (limits.maxY - limits.minY + 2 * margin) + "px";
        }
      } else if (currentMode === "expanded" || currentMode === "collapsed") {
        let leftFixed = 17, topFixed = 55;
        let margin = 20;
        let limits = computeModeRegion();
        let rightLimit = limits.maxX + margin;
        let bottomLimit = limits.maxY + margin;
        bg.style.left = leftFixed + "px";
        bg.style.top = topFixed + "px";
        bg.style.width = (rightLimit - leftFixed) + "px";
        bg.style.height = (bottomLimit - topFixed) + "px";
      }
      bg.style.opacity = "1";
    }
    
    async function loadData() {
      elements = await (await fetch('elements.json')).json();
      positions = await (await fetch('positions.json')).json();
    }
    
    function initializePeriodsCanvas() {
      new p5(function(p) {
        p.setup = function() {
          let canvas = p.createCanvas(40, 292);
          canvas.parent("canvasPeriods");
          let container = document.getElementById("canvasPeriods");
          let bgLeft = parseInt(document.getElementById("canvasTableBackground").style.left);
          container.style.left = (bgLeft + 6) + "px";
          container.style.top = positions[currentMode]["1"].y + "px";
          p.noStroke();
          p.textAlign(p.CENTER, p.CENTER);
          p.textSize(11);
          p.textStyle(p.BOLD);
          const periodLabels = ["1η K", "2η L", "3η M", "4η N", "5η Ο", "6η Ρ", "7η Q"];
          for (let i = 0; i < 7; i++) {
            p.fill(240);
            p.rect(0, i * 42, 40, 40);
            p.fill(0);
            p.text(periodLabels[i], 20, i * 42 + 20);
          }
        };
      });
    }
    
    function initGroupsCanvases() {
      new p5(function(p) {
        p.setup = function() {
          let canvas = p.createCanvas(82, 40);
          canvas.parent("canvasS_groups");
          p.background(240);
          for (let col = 0; col < 2; col++) {
            p.noStroke();
            p.noFill();
            p.rect(col * 42, 0, 40, 20);
            p.rect(col * 42, 20, 40, 20);
          }
          p.noStroke();
          p.fill(0);
          p.textAlign(p.CENTER, p.CENTER);
          p.textSize(11);
          p.textStyle(p.BOLD);
          p.text("1", 20, 10);
          p.text("2", 20 + 42, 10);
          p.text("IA", 20, 30);
          p.text("IIA", 20 + 42, 30);
        };
      });
      
      new p5(function(p) {
        p.setup = function() {
          let canvas = p.createCanvas(418, 40);
          canvas.parent("canvasD_groups");
          p.background(240);
          for (let col = 0; col < 10; col++) {
            p.noStroke();
            p.noFill();
            p.rect(col * 42, 0, 40, 20);
            p.rect(col * 42, 20, 40, 20);
          }
          p.noStroke();
          p.fill(0);
          p.textAlign(p.CENTER, p.CENTER);
          p.textSize(11);
          p.textStyle(p.BOLD);
          for (let c = 0; c < 10; c++) {
            let x = c * 42;
            p.text((c + 3).toString(), x + 20, 10);
          }
          const oldLabels = ["IIIB", "IVB", "VB", "VIB", "VIIB", "VIIIB", "VIIIB", "VIIIB", "IB", "IIB"];
          for (let c = 0; c < 10; c++) {
            let x = c * 42;
            p.text(oldLabels[c], x + 20, 30);
          }
        };
      });
      
      new p5(function(p) {
        p.setup = function() {
          let canvas = p.createCanvas(250, 40);
          canvas.parent("canvasP_groups");
          p.background(240);
          for (let col = 0; col < 6; col++) {
            p.noStroke();
            p.noFill();
            p.rect(col * 42, 0, 40, 20);
            p.rect(col * 42, 20, 40, 20);
          }
          p.noStroke();
          p.fill(0);
          p.textAlign(p.CENTER, p.CENTER);
          p.textSize(11);
          p.textStyle(p.BOLD);
          for (let c = 0; c < 6; c++) {
            let x = c * 42;
            p.text((c + 13).toString(), x + 20, 10);
          }
          const oldLabels = ["IIIA", "IVA", "VA", "VIA", "VIIA", "VIIIA"];
          for (let c = 0; c < 6; c++) {
            let x = c * 42;
            p.text(oldLabels[c], x + 20, 30);
          }
        };
      });
      
      ["S", "D", "P"].forEach(sector => {
        let sectorCanvas = document.getElementById("canvas" + sector);
        let groupCanvas = document.getElementById("canvas" + sector + "_groups");
        groupCanvas.style.left = sectorCanvas.style.left;
        groupCanvas.style.top = (parseInt(positions[currentMode]["1"].y) - 42 - 2) + "px";
      });
    }
    
    function initializeSectorsCanvas() {
      let blocks = ["s", "p", "d", "f"];
      blocks.forEach(block => {
        let container = document.getElementById("canvas" + block.toUpperCase());
        container.innerHTML = "";
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        elements.filter(e => e.block === block).forEach(e => {
          let num = Number(e.number);
          if (currentMode === "start") {
            // Εμφανίζονται τα στοιχεία 3 έως currentZ, και για τα 1,2 μόνο αν έχουν ενεργοποιηθεί μέσω extraElements.
            if ((num < 3 && !extraElements[num]) || num > currentZ) return;
          }
          let pos = positions[currentMode][e.number] || ((e.number === "1" || e.number === "2") ? positions["start"][e.number] : null);
          if (pos) {
            let yForMin = pos.y, yForMax = pos.y;
            if (currentMode === "start") {
              if (block === "p" && num >= 21 && num <= 30) yForMax += getShift(num, block);
              else if ((block === "p" || block === "d") && num >= 57 && num <= 70) yForMax += getShift(num, block);
            }
            minX = Math.min(minX, pos.x);
            minY = Math.min(minY, yForMin);
            maxX = Math.max(maxX, pos.x + pos.width);
            maxY = Math.max(maxY, yForMax + pos.height);
          }
        });
        if (minX === Infinity || minY === Infinity) return;
        if (currentMode === "start" && (block === "p" || block === "d"))
          container.style.left = (minX + getShiftContainer(block)) + "px";
        else
          container.style.left = minX + "px";
        container.style.top = minY + "px";
        container.style.width = (maxX - minX) + "px";
        container.style.height = (maxY - minY) + "px";
        new p5(function(p) {
          p.setup = function() {
            let canvas = p.createCanvas(parseInt(container.style.width), parseInt(container.style.height));
            canvas.parent("canvas" + block.toUpperCase());
            drawElements(p, block, minX, minY);
          };
        });
      });
    }
    
    // Συνάρτηση drawElements ώστε οι αριθμοί να στοιχίζονται στο κέντρο
    function drawElements(p, block, containerLeft, containerTop) {
      let colors = { s: "#FF477E", p: "#26FF31", d: "#3F99FF", f: "#FFD051" };
      elements.filter(e => e.block === block).forEach(e => {
        let num = Number(e.number);
        if (currentMode === "start") {
          if ((num < 3 && !extraElements[num]) || num > currentZ) return;
        }
        let pos = positions[currentMode][e.number] || ((e.number === "1" || e.number === "2") ? positions["start"][e.number] : null);
        if (pos) {
          let relativeX = pos.x - containerLeft;
          let relativeY = pos.y - containerTop;
          if (currentMode === "start") {
            if (block === "p" && num >= 21 && num <= 30)
              relativeY += getShift(num, block);
            else if ((block === "p" || block === "d") && num >= 57 && num <= 70)
              relativeY += getShift(num, block);
          }
          p.fill(colors[block] || "#CCCCCC");
          p.rect(relativeX, relativeY, pos.width, pos.height, 5);
          p.fill(0);
          p.textSize(13);
          p.textStyle(p.BOLD);
          p.textAlign(p.CENTER, p.CENTER);
          p.text(e.number, relativeX + pos.width / 2, relativeY + pos.height / 2);
        }
      });
    }
    
    // Hit-testing στο κέντρο της τρέχουσας περιοχής
    function logHitTestCenter() {
      let region = computeModeRegionUpdated();
      if (region) {
        let centerX = (region.minX + region.maxX) / 2;
        let centerY = (region.minY + region.maxY) / 2;
        console.log("Κλήση hit test στο κέντρο: (" + centerX + ", " + centerY + ")");
        performHitTest(centerX, centerY);
      }
    }
    
    // Κουμπί "Συμπλήρωσε": Μεταβαίνουμε στην expanded κατάσταση (currentZ=123)
    document.getElementById('fillAll').addEventListener('click', function() {
      document.querySelectorAll('.canvas').forEach(el => el.innerHTML = '');
      currentMode = "expanded";
      currentZ = 123;
      initializeBackgroundCanvas();
      initializeSectorsCanvas();
      initializePeriodsCanvas();
      initGroupsCanvases();
      document.getElementById('toggleFBlock').disabled = false;
      console.log("FillAll: currentZ set to", currentZ, "- πλήρης εμφάνιση (expanded)");
      updateCellsPositions();
      logHitTestCenter();
    });
    
    // Κουμπί "Σύμπτυξε/Ανάπτυξε"
    document.getElementById('toggleFBlock').addEventListener('click', function() {
      isCollapsed = !isCollapsed;
      this.textContent = isCollapsed ? "Ανάπτυξε" : "Σύμπτυξε";
      currentMode = isCollapsed ? "collapsed" : "expanded";
      initializeBackgroundCanvas();
      initializeSectorsCanvas();
      ["S", "D", "P"].forEach(sector => {
        let sectorCanvas = document.getElementById("canvas" + sector);
        let groupCanvas = document.getElementById("canvas" + sector + "_groups");
        groupCanvas.style.left = sectorCanvas.style.left;
        groupCanvas.style.top = (parseInt(positions[currentMode]["1"].y) - 42 - 2) + "px";
      });
      console.log("ToggleFBlock: Mode changed to", currentMode);
      updateCellsPositions();
      logHitTestCenter();
    });
    
    // Κουμπί "Επόμενο": Λειτουργεί μόνο σε κατάσταση "start" σύμφωνα με τη νέα λογική:
    // - Εάν currentZ < 119: αύξηση κανονικά.
    // - Όταν currentZ == 118: στο επόμενο κλικ γίνεται currentZ = 119 και extraElements["1"] ενεργοποιείται.
    // - Όταν currentZ == 119: στο επόμενο κλικ γίνεται currentZ = 120 και extraElements["2"] ενεργοποιείται.
    // - Όταν currentZ == 120: στο επόμενο κλικ γίνεται currentZ = 121 και showPeriods ενεργοποιείται.
    // - Όταν currentZ == 121: στο επόμενο κλικ γίνεται currentZ = 122, εξαφανίζονται όλα και μεταβαίνουμε σε fillAll (expanded, currentZ = 123).
    document.getElementById('nextState').addEventListener('click', function() {
      if (currentMode !== "start") {
        console.log("Το κουμπί 'Επόμενο' λειτουργεί μόνο στην κατάσταση 'start'. Κάντε Reset για επαναφορά.");
        return;
      }
      if (currentZ < 118) {
        currentZ++;
      } else if (currentZ === 118) {
        currentZ = 119;
        extraElements["1"] = true;
      } else if (currentZ === 119) {
        currentZ = 120;
        extraElements["2"] = true;
      } else if (currentZ === 120) {
        currentZ = 121;
        showPeriods = true;
      } else if (currentZ === 121) {
        currentZ = 122;
        // Στο 122 εξαφανίζονται όλα και μεταβαίνει στην expanded κατάσταση (fillAll)
        currentMode = "expanded";
        currentZ = 123;
      }
      initializeBackgroundCanvas();
      initializeSectorsCanvas();
      if (showPeriods) initializePeriodsCanvas();
      updateCellsPositions();
      logHitTestCenter();
      console.log("NextState: currentZ =", currentZ, "extraElements:", extraElements, "showPeriods:", showPeriods);
    });
    
    // Κουμπί "Reset": Πλήρης επαναφορά της εφαρμογής
    document.getElementById('reset').addEventListener('click', function() {
      currentMode = "start";
      currentZ = 3;
      extraElements = {};
      showPeriods = false;
      location.reload();
    });
    
    // Hit-testing χρησιμοποιώντας τις ενημερωμένες θέσεις
    function performHitTest(x, y) {
      let region = computeModeRegionUpdated();
      if (!region) {
         console.log("Δεν εμφανίζονται στοιχεία στο τρέχον mode.");
         return;
      }
      let regionLeft = region.minX, regionTop = region.minY;
      if (x < regionLeft || x > region.maxX || y < regionTop || y > region.maxY) {
         console.log("Κλικ εκτός περιοχής στοιχείων.");
         return;
      }
      let relX = x - regionLeft, relY = y - regionTop;
      let offCanvas = document.getElementById("offscreenCanvas");
      offCanvas.width = region.maxX - region.minX;
      offCanvas.height = region.maxY - region.minY;
      let offCtx = offCanvas.getContext("2d");
      offCtx.clearRect(0, 0, offCanvas.width, offCanvas.height);
      for (let key in currentCellPositions) {
         let pos = currentCellPositions[key];
         let drawX = pos.x - regionLeft;
         let drawY = pos.y - regionTop;
         let num = Number(key);
         let r = (num * 37) % 256;
         let g = (num * 67) % 256;
         let b = (num * 97) % 256;
         offCtx.fillStyle = "rgb(" + r + "," + g + "," + b + ")";
         offCtx.fillRect(drawX, drawY, pos.width, pos.height);
      }
      let pixel = offCtx.getImageData(relX, relY, 1, 1).data;
      if (pixel[3] === 0) {
         console.log("Δεν ανιχνεύτηκε στοιχείο στο σημείο (" + x + ", " + y + ") μέσω color picking.");
      } else {
         console.log("Color Picking: Pixel at (" + x + ", " + y + ") =", pixel);
         let found = null;
         for (let key in currentCellPositions) {
            let pos = currentCellPositions[key];
            let num = Number(key);
            let r = (num * 37) % 256;
            let g = (num * 67) % 256;
            let b = (num * 97) % 256;
            if (pixel[0] === r && pixel[1] === g && pixel[2] === b) {
                found = key;
                break;
            }
         }
         if (found)
            console.log("Εντοπίστηκε στοιχείο με Ζ =", found);
         else
            console.log("Δεν βρέθηκε αντιστοιχία για το χρώμα", pixel);
      }
      let col = Math.floor(relX / cellSize);
      let row = Math.floor(relY / cellSize);
      console.log("Direct Calculation: Row =", row, "Col =", col);
    }
    
    // Ενσωμάτωση του hit-testing στο p5 canvas για κάθε block
    function initializeCanvases() {
      Object.keys({ s: 1, p: 1, d: 1, f: 1 }).forEach(function(block) {
        new p5(function(p) {
          p.setup = function() {
            let config = { cols: 10, rows: 7 };
            if (block === "s") config = { cols: 2, rows: 7 };
            else if (block === "p") config = { cols: 6, rows: 7 };
            else if (block === "d") config = { cols: 10, rows: 7 };
            else if (block === "f") config = { cols: 14, rows: 7 };
            let canvas = p.createCanvas(config.cols * cellSize, config.rows * cellSize);
            canvas.elt.getContext("2d", { willReadFrequently: true });
            canvas.parent("canvas" + block.toUpperCase());
            p.skipNextClick = true;
            setTimeout(() => { p.skipNextClick = false; }, 100);
            p.mouseClicked = function(event) {
              if (p.skipNextClick) return;
              let globalX = event.clientX;
              let globalY = event.clientY;
              performHitTest(globalX, globalY);
            };
            window.drawElements(p, block);
          };
        });
      });
    }
    
    // Δέσμευση της συνάρτησης drawElements σε global επίπεδο
    window.drawElements = drawElements;
    
    // Φόρτωση δεδομένων και αρχικοποίηση των canvases (ανάλογα με το mode)
    loadData().then(() => {
      if (currentMode === "expanded" || currentMode === "collapsed") {
        initializeBackgroundCanvas();
        initializeSectorsCanvas();
        initializePeriodsCanvas();
        initGroupsCanvases();
        initializeCanvases();
      } else if (currentMode === "start") {
        initializeBackgroundCanvas();
        initializeSectorsCanvas();
        initializeCanvases();
      }
      updateCellsPositions();
      console.log("Data loaded and canvases initialized.");
    });
  </script>
</body>
</html>
