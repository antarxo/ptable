<!DOCTYPE html>
<html lang="el">
<head>
  <meta charset="UTF-8">
  <title>Περιοδικός Πίνακας - Συμπλήρωσε με Info Panels & Balloon</title>
  <link href="https://fonts.googleapis.com/css?family=Roboto&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
  <style>
    /* Αρχικά στυλ όπως στο ptablelike.html */
    body { 
      font-family: 'Roboto', sans-serif; 
      margin: 0; 
      overflow: hidden; 
      background: #f7f7f7; 
    }
    .canvas { 
      position: absolute; 
      background: transparent; 
      transition: all 0.5s ease-in-out; 
    }
    canvas {
      padding: 8px;
      filter: drop-shadow(4px 4px 4px rgba(0,0,0,0.5));
      overflow: visible;
    }
    /* Background canvas */
    #canvasTableBackground {
      position: absolute; 
      background: white; 
      border: 1px solid rgba(0,0,0,0.1);
      box-shadow: 6px 6px 10px rgba(0,0,0,0.3); 
      z-index: -10;
      opacity: 1;
      transition: all 0.5s ease-in-out;
    }
    /* Ομαδοποίηση καμβάδων ομάδων */
    #canvasS_groups, #canvasD_groups, #canvasP_groups { 
      position: absolute;
      z-index: 60;
    }
    /* Καμβάδες τομέων και περιοδών */
    #canvasS { z-index: 10; }
    #canvasF { z-index: 20; }
    #canvasD { z-index: 30; }
    #canvasP { z-index: 40; }
    #canvasPeriods { z-index: 50; }
    /* Κουμπιά */
    #buttonPanel {
      position: fixed; 
      bottom: 20px; 
      right: 20px; 
      z-index: 100;
      display: flex; 
      flex-direction: column;
      gap: 5px;
    }
    #buttonPanel button {
      background-color: #008CBA; 
      color: white; 
      padding: 10px 15px;
      border: none; 
      border-radius: 5px;
      cursor: pointer;
      box-shadow: 4px 4px 4px rgba(0,0,0,0.5);
    }
    /* Info Panels και Balloon Tooltip (δανεισμένα από ALLtoDOM1) */
    #infoPanelExpanded, #infoPanelCollapsed {
      background: #fff;
      border: 2px solid #333;
      border-radius: 8px;
      box-shadow: 0 3px 3px rgba(0,0,0,0.3);
      padding: 10px;
      position: fixed;
      z-index: 150;
      font-size: 16px;
      transition: all 0.5s ease;
    }
    #infoPanelExpanded {
      bottom: 20px;
      left: 20px;
      display: block;
    }
    #infoPanelCollapsed {
      bottom: 20px;
      right: 20px;
      display: none;
    }
    #balloonTooltip {
      position: absolute;
      background: #fff;
      border: 1px solid #333;
      border-radius: 10px;
      padding: 10px;
      box-shadow: 0 3px 3px rgba(0,0,0,0.3);
      z-index: 200;
      display: none;
      transition: all 0.2s ease;
    }
    /* Overlay για κλικ (με υψηλό z-index) */
    #clickOverlay {
      position: absolute;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      z-index: 110;
      background: transparent;
    }
  </style>
</head>
<body>

  <!-- Καμβάδες -->
  <div id="canvasTableBackground"></div>
  <div id="canvasS_groups" class="canvas"></div>
  <div id="canvasD_groups" class="canvas"></div>
  <div id="canvasP_groups" class="canvas"></div>
  
  <div id="canvasPeriods" class="canvas"></div>
  <div id="canvasS" class="canvas"></div>
  <div id="canvasD" class="canvas"></div>
  <div id="canvasP" class="canvas"></div>
  <div id="canvasF" class="canvas"></div>

  <!-- Info Panels -->
  <div id="infoPanelExpanded"></div>
  <div id="infoPanelCollapsed"></div>

  <!-- Balloon Tooltip -->
  <div id="balloonTooltip"></div>

  <!-- Overlay για κλικ -->
  <div id="clickOverlay"></div>

  <!-- Κουμπιά -->
  <div id="buttonPanel">
    <button id="nextState">Επόμενο</button>
    <button id="fillAll">Συμπλήρωσε</button>
    <button id="toggleFBlock" disabled>Σύμπτυξε</button>
    <button id="reset">Reset</button>
  </div>

  <script>
    /***************************************
     * Global Variables & Configuration
    ***************************************/
    let elements = [];
    let positions = {};
    let isCollapsed = false;
    // currentMode: "expanded" για την πλήρη εμφάνιση (Συμπλήρωσε), "start" για τη διαδικασία Επόμενο
    let currentMode = "expanded";
    let currentZ = 0;
    let extraElements = {};
    let postFillingStep = 0;
    let showPeriods = false;

    /***************************************
     * Offscreen Canvas για Color Picking
     * Ορίζουμε το willReadFrequently για βελτιστοποίηση
    ***************************************/
    let pickingCanvas = document.createElement('canvas');
    let pickingCtx = pickingCanvas.getContext('2d', {willReadFrequently: true});
    let pickingMap = {};

    // Παράγει μοναδικό RGB χρώμα για κάθε στοιχείο (υποθέτουμε elementNumber ≤ 255)
    function getUniqueColor(elementNumber) {
      let r = elementNumber;
      return `rgb(${r},0,0)`;
    }

    /***************************************
     * Συναρτήσεις υπολογισμού θέσεων (παραμένουν όπως ήταν)
    ***************************************/
    function getShift(num, block) {
      if (currentMode !== "start") return 0;
      if (block === "p" && num >= 21 && num <= 30) {
        let effectiveZ = Math.min(currentZ, 30);
        return (effectiveZ - 20) * 42;
      }
      if ((block === "p" || block === "d") && num >= 57 && num <= 70) {
        let effective = Math.min(currentZ, 70);
        return (effective - 56) * 42;
      }
      return 0;
    }

    function getShiftContainer(block) {
      if (currentMode !== "start") return 0;
      if (block === "p") {
        if (currentZ <= 20) return 0;
        else if (currentZ <= 30) return (currentZ - 20) * 42;
        else if (currentZ <= 56) return 42;
        else if (currentZ <= 70) return 42 + (currentZ - 56) * 42;
        else return 42 + (70 - 56) * 42;
      } else if (block === "d") {
        if (currentZ < 57) return 0;
        else if (currentZ <= 70) return (currentZ - 56) * 42;
        else return (70 - 56) * 42;
      }
      return 0;
    }

    function computeNextBgDimensions() {
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      elements.forEach(e => {
        let num = Number(e.number);
        if ((num < 3 && !extraElements[num]) || num > currentZ) return;
        let pos = positions[currentMode][e.number];
        if (pos) {
          let x = pos.x, y = pos.y;
          if (currentMode === "start" && (e.block === "p" || e.block === "d")) {
            x += getShiftContainer(e.block);
          }
          if (currentMode === "start") {
            if (e.block === "p" && num >= 21 && num <= 30) y += getShift(num, e.block);
            else if ((e.block === "p" || e.block === "d") && num >= 57 && num <= 70) y += getShift(num, e.block);
          }
          minX = Math.min(minX, x);
          minY = Math.min(minY, y);
          maxX = Math.max(maxX, x + pos.width);
          maxY = Math.max(maxY, y + pos.height);
        }
      });
      return { minX, minY, maxX, maxY };
    }

    function computeRightLimit(block) {
      let maxX = -Infinity;
      elements.filter(e => e.block === block).forEach(e => {
        let pos = positions[currentMode][e.number];
        if (pos) maxX = Math.max(maxX, pos.x + pos.width);
      });
      return maxX;
    }
    function computeBottomLimit(block) {
      let maxY = -Infinity;
      elements.filter(e => e.block === block).forEach(e => {
        let pos = positions[currentMode][e.number];
        if (pos) maxY = Math.max(maxY, pos.y + pos.height);
      });
      return maxY;
    }

    function initializeBackgroundCanvas() {
      let bg = document.getElementById("canvasTableBackground");
      let margin = 20;
      if (currentMode === "start") {
        let limits = computeNextBgDimensions();
        if (limits) {
          let leftFixed = 17;
          bg.style.left = leftFixed + "px";
          bg.style.top = (limits.minY - margin) + "px";
          bg.style.width = (limits.maxX + margin - leftFixed) + "px";
          bg.style.height = (limits.maxY - limits.minY + 2 * margin) + "px";
        }
      } else if (currentMode === "expanded" || currentMode === "collapsed") {
        let leftFixed = 17, topFixed = 55;
        let rightLimit = computeRightLimit("p") + margin;
        let bottomLimit = computeBottomLimit("f") + margin;
        bg.style.left = leftFixed + "px";
        bg.style.top = topFixed + "px";
        bg.style.width = (rightLimit - leftFixed) + "px";
        bg.style.height = (bottomLimit - topFixed) + "px";
      }
      bg.style.opacity = "1";
    }

    function initializeSectorsCanvas() {
      let blocks = ["s", "p", "d", "f"];
      blocks.forEach(block => {
        let container = document.getElementById("canvas" + block.toUpperCase());
        container.innerHTML = "";
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        elements.filter(e => e.block === block).forEach(e => {
          let num = Number(e.number);
          if (currentMode === "start" && ((num < 3 && !extraElements[num]) || num > currentZ)) return;
          let pos = positions[currentMode][e.number];
          if (pos) {
            let yForMax = pos.y;
            if (currentMode === "start") {
              if (block === "p" && num >= 21 && num <= 30) yForMax += getShift(num, block);
              else if ((block === "p" || block === "d") && num >= 57 && num <= 70) yForMax += getShift(num, block);
            }
            minX = Math.min(minX, pos.x);
            minY = Math.min(minY, pos.y);
            maxX = Math.max(maxX, pos.x + pos.width);
            maxY = Math.max(maxY, yForMax + pos.height);
          }
        });
        if (minX === Infinity || minY === Infinity) return;
        if (currentMode === "start" && (block === "p" || block === "d"))
          container.style.left = (minX + getShiftContainer(block)) + "px";
        else container.style.left = minX + "px";
        container.style.top = minY + "px";
        container.style.width = (maxX - minX) + "px";
        container.style.height = (maxY - minY) + "px";
        new p5(function(p) {
          p.setup = function() {
            let canvas = p.createCanvas(parseInt(container.style.width), parseInt(container.style.height));
            canvas.parent("canvas" + block.toUpperCase());
            drawElements(p, block, minX, minY);
          };
        });
      });
    }

    function drawElements(p, block, containerLeft, containerTop) {
      let colors = { s: "#FF477E", p: "#26FF31", d: "#3F99FF", f: "#FFD051" };
      elements.filter(e => e.block === block).forEach(e => {
        let num = Number(e.number);
        if (currentMode === "start" && ((num < 3 && !extraElements[num]) || num > currentZ)) return;
        let pos = positions[currentMode][e.number];
        if (pos) {
          let relativeX = pos.x - containerLeft;
          let relativeY = pos.y - containerTop;
          if (currentMode === "start") {
            if (block === "p" && num >= 21 && num <= 30)
              relativeY += getShift(num, block);
            else if ((block === "p" || block === "d") && num >= 57 && num <= 70)
              relativeY += getShift(num, block);
          }
          p.fill(colors[block] || "#CCCCCC");
          p.rect(relativeX, relativeY, pos.width, pos.height, 5);
          p.fill(0);
          p.textSize(13);
          p.textStyle(p.BOLD);
          p.textAlign(p.CENTER, p.CENTER);
          p.text(e.number, relativeX + pos.width/2, relativeY + pos.height/2);
        }
      });
    }

    /***************************************
     * Color Picking: Ζωγράφιση του offscreen canvas με μοναδικά χρώματα για κάθε κελί
    ***************************************/
    function updatePickingCanvas() {
      let limits = computeNextBgDimensions();
      if (!limits) return;
      let margin = 20, leftFixed = 17;
      let canvasLeft = leftFixed;
      let canvasTop = limits.minY - margin;
      let canvasWidth = (limits.maxX + margin - leftFixed);
      let canvasHeight = (limits.maxY - limits.minY + 2 * margin);
      pickingCanvas.width = canvasWidth;
      pickingCanvas.height = canvasHeight;
      pickingCtx.clearRect(0, 0, canvasWidth, canvasHeight);
      pickingMap = {};
      elements.forEach(e => {
        let num = Number(e.number);
        if ((num < 3 && !extraElements[num]) || num > currentZ) return;
        let pos = positions[currentMode][e.number];
        if (pos) {
          let x = pos.x, y = pos.y;
          if (currentMode === "start" && (e.block === "p" || e.block === "d"))
            x += getShiftContainer(e.block);
          if (currentMode === "start") {
            if (e.block === "p" && num >= 21 && num <= 30)
              y += getShift(num, e.block);
            else if ((e.block === "p" || e.block === "d") && num >= 57 && num <= 70)
              y += getShift(num, e.block);
          }
          let relX = x - canvasLeft;
          let relY = y - (limits.minY - margin);
          let uniqueColor = getUniqueColor(num);
          pickingCtx.fillStyle = uniqueColor;
          pickingCtx.fillRect(relX, relY, pos.width, pos.height);
          pickingMap[uniqueColor] = e;
        }
      });
    }

    // Χειριστής κλικ μέσω του overlay (clickOverlay)
    function onOverlayClick(event) {
      // Βρίσκουμε το σημείο κλικ σε σχέση με το canvasTableBackground
      let bg = document.getElementById("canvasTableBackground");
      let rect = bg.getBoundingClientRect();
      let clickX = event.clientX - rect.left;
      let clickY = event.clientY - rect.top;
      let pixel = pickingCtx.getImageData(clickX, clickY, 1, 1).data;
      let clickedColor = `rgb(${pixel[0]},${pixel[1]},${pixel[2]})`;
      let element = pickingMap[clickedColor];
      if (element) {
        updateInfo(element.number);
        showBalloon(element);
      }
    }
    document.getElementById("clickOverlay").addEventListener("click", onOverlayClick);

    /***************************************
     * Balloon Tooltip: Εμφάνιση πληροφοριών στοιχείου
    ***************************************/
    function showBalloon(element) {
      let balloon = document.getElementById("balloonTooltip");
      balloon.innerHTML = `<strong>${element.symbol}</strong> (${element.name})<br>Ζ=${element.number}`;
      let pos = positions[currentMode][element.number];
      if (pos) {
        let bgLeft = parseInt(document.getElementById("canvasTableBackground").style.left) || 0;
        let bgTop = parseInt(document.getElementById("canvasTableBackground").style.top) || 0;
        let absX = pos.x + bgLeft;
        let absY = pos.y + bgTop;
        balloon.style.left = (absX + pos.width + 10) + "px";
        balloon.style.top = absY + "px";
        balloon.style.display = "block";
      }
    }

    /***************************************
     * Info Panels: Ενημέρωση πληροφοριών για το επιλεγμένο στοιχείο
     * Εφαρμόζεται μόνο για τη λειτουργία "Συμπλήρωσε" (expanded)
    ***************************************/
    function updateInfo(clickedZ) {
      let infoPanel = document.getElementById("infoPanelExpanded");
      document.getElementById("infoPanelCollapsed").style.display = "none";
      let numberToShow = (clickedZ === 119 ? 1 : (clickedZ === 120 ? 2 : clickedZ));
      let element = elements.find(e => Number(e.number) === numberToShow);
      if (!element) return;
      infoPanel.innerHTML = `<strong>Ζ=${element.number}</strong> ${element.symbol} – ${element.name}`;
      infoPanel.style.display = "block";
    }

    /***************************************
     * updateAll: Ενημέρωση background, sectors και picking canvas
    ***************************************/
    function updateAll() {
      initializeBackgroundCanvas();
      initializeSectorsCanvas();
      updatePickingCanvas();
    }

    /***************************************
     * Event Listeners για τα κουμπιά
    ***************************************/
    // "Συμπλήρωσε": Θέτει currentZ = 123, ενημερώνει το state και δεν αλλάζει τη λογική συμπλήρωσης
    document.getElementById('fillAll').addEventListener('click', function() {
      // Μην καθαρίζουμε πλέον όλα τα .canvas ώστε να παραμείνουν τα περιεχόμενα
      currentMode = "expanded";
      currentZ = 123;
      initializeBackgroundCanvas();
      initializeSectorsCanvas();
      updateAll();
      // Δεν αλλάζουμε πλέον το z-index του canvasTableBackground
      document.getElementById('toggleFBlock').disabled = false;
      console.log("FillAll: currentZ set to", currentZ);
      updateInfo(currentZ);
    });

    // "Επόμενο": Διαδικασία "start" όπως ήταν
    document.getElementById('nextState').addEventListener('click', function() {
      if (currentMode !== "start") {
        currentMode = "start";
        currentZ = 3;
        postFillingStep = 0;
        extraElements = {};
        showPeriods = false;
      } else {
        if (currentZ < 118) {
          currentZ++;
        } else {
          postFillingStep++;
          if (postFillingStep === 1) extraElements["1"] = true;
          else if (postFillingStep === 2) extraElements["2"] = true;
          else if (postFillingStep === 3) {
            showPeriods = true;
            // Ενσωμάτωση καμβά περιόδων αν χρειάζεται
          } else if (postFillingStep === 4) {
            document.getElementById('fillAll').click();
            return;
          }
        }
      }
      updateAll();
      console.log("Start mode: currentZ =", currentZ, "postFillingStep =", postFillingStep);
    });

    // "Σύμπτυξε/Ανάπτυξε": Εναλλαγή μεταξύ expanded και collapsed info panels (δεν επηρεάζει τη λειτουργία "Συμπλήρωσε" εδώ)
    document.getElementById('toggleFBlock').addEventListener('click', function() {
      isCollapsed = !isCollapsed;
      if (isCollapsed) {
        currentMode = "collapsed";
        document.getElementById("infoPanelCollapsed").style.display = "block";
        document.getElementById("infoPanelExpanded").style.display = "none";
        this.textContent = "Ανάπτυξε";
      } else {
        currentMode = "expanded";
        document.getElementById("infoPanelExpanded").style.display = "block";
        document.getElementById("infoPanelCollapsed").style.display = "none";
        this.textContent = "Σύμπτυξε";
      }
      updateAll();
    });

    // "Reset": Επαναφορά της σελίδας
    document.getElementById('reset').addEventListener('click', function() {
      location.reload();
    });

    /***************************************
     * Φόρτωση Δεδομένων: elements και positions από τα JSON αρχεία
    ***************************************/
    async function loadData() {
      elements = await (await fetch('elements.json')).json();
      positions = await (await fetch('positions.json')).json();
    }
    window.addEventListener('load', loadData);
  </script>
</body>
</html>
